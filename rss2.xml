<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Freya&#39;s blog</title>
    <link>gofee.me/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>灵动，洒脱，决然，坚韧</description>
    <pubDate>Wed, 26 Jul 2017 08:25:31 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>关于storyboard不得不说的事</title>
      <link>gofee.me/2017/05/05/storyboard-loading/</link>
      <guid>gofee.me/2017/05/05/storyboard-loading/</guid>
      <pubDate>Fri, 05 May 2017 03:39:02 GMT</pubDate>
      <description>
      
        &lt;p&gt;自 iOS 5 时代苹果推出 Storyboard（以下简称SB）以来，关于使用代码手写 UI、SB 和 xib 之间的争论就一直存在。问题主要在于 Storyboard 的加载过程是否会影响性能，下面就分析一下 Storyboard 中的 ViewController 是
      
      </description>
      
      <content:encoded><![CDATA[<p>自 iOS 5 时代苹果推出 Storyboard（以下简称SB）以来，关于使用代码手写 UI、SB 和 xib 之间的争论就一直存在。问题主要在于 Storyboard 的加载过程是否会影响性能，下面就分析一下 Storyboard 中的 ViewController 是怎么加载出来的。</p>
<p>细心的同学会发现，在编译的时候 Xcode 有个 Compiling Storyboard files 的过程。编译过程中，项目里用到的 SB 文件也会被编译，并以 <code>.storyboarc</code> 为扩展名最终保存在 APP 包内。<code>.storyboardc</code> 是一个文件夹，里面保存了描述编译后的 SB 信息的 <code>Info.plist</code> 文件，以及一系列 <code>.nib</code> 文件。原来的 SB 中的每个对象（也就是每个 ViewController）将会被编译成一个单独的 <code>.nib</code>，<code>.nib</code> 中包含了编码后的对应的对象层级。在加载一个 SB，并从中读取 ViewController 类型和 nib 的关系，来完成 <code>UIStoryboard</code> 的初始化。接下来读取某个 nib，并使用<code>UINibDecoder</code> 进行解码，将 nib 二进制还原为实际的对象，最后调用该对象的 <code>initWithCoder：</code> 完成各个属性的解码。最后，调用 <code>awakeFromNib</code> 方法，来通知开发者从 nib 的加载已经完毕。</p>
<img src="/2017/05/05/storyboard-loading/storyboard的加载过程.png" alt="Storyboard 的加载过程" title="Storyboard 的加载过程">
<p>可以看出，从只有一个 ViewController 的 SB 中加载这个 VC，与从有多个 ViewController 的 SB 中加载的情况，速度上并不会有什么区别。</p>
<p>原文： <a href="https://onevcat.com/2017/04/storyboard-argue/" target="_blank" rel="external">再看关于 Storyboard 的一些争论</a></p>
]]></content:encoded>
      
      <comments>gofee.me/2017/05/05/storyboard-loading/#disqus_thread</comments>
    </item>
    
    <item>
      <title>AFNetworking README 中文版</title>
      <link>gofee.me/2017/01/25/AFNetworking-translate/</link>
      <guid>gofee.me/2017/01/25/AFNetworking-translate/</guid>
      <pubDate>Wed, 25 Jan 2017 12:23:15 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;AFNetworking-README-中文版&quot;&gt;&lt;a href=&quot;#AFNetworking-README-中文版&quot; class=&quot;headerlink&quot; title=&quot;AFNetworking README 中文版&quot;&gt;&lt;/a&gt;AFNetworking READ
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="AFNetworking-README-中文版"><a href="#AFNetworking-README-中文版" class="headerlink" title="AFNetworking README 中文版"></a>AFNetworking README 中文版</h1><p>AFNetworking是iOS和Mac OS X平台上的轻量级网络库，在Foudation URL加载系统基础上构建，对构建于Cocoa的强大高级的网络抽象进行了扩充。它具有设计良好的、富有特性的、模块化结构的API接口集。</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="NSURLSession-会话"><a href="#NSURLSession-会话" class="headerlink" title="NSURLSession 会话"></a>NSURLSession 会话</h3><ul>
<li>AFURLSessionManager</li>
<li>AFHTTPSessionManager</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li><code>&lt;AFURLRequestSerialization&gt;</code><ul>
<li>AFHTTPRequestSerializer</li>
<li>AFJSONRequestSerializer</li>
<li>AFPropertyListRequestSerializer</li>
</ul>
</li>
<li><code>&lt;AFURLResponseSerialization&gt;</code><ul>
<li>AFHTTPResponseSerializer</li>
<li>AFJSONResponseSerializer</li>
<li>AFXMLParserResponseSerializer</li>
<li>AFXMLDocumentResponseSerializer(Mac OS X)</li>
<li>AFPropertyListResponseSerializer</li>
<li>AFImageResponseSerializer</li>
<li>AFCompoundResponseSerializer</li>
</ul>
</li>
</ul>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ul>
<li>AFSecurityPolicy</li>
<li>AFNetworkReachabilityManager</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h3><p><code>AFURLSessionManager</code>在一个定义好的<code>NSURLSessionConfiguration</code>对象基础上创建并管理一个<code>NSURLSession</code>对象, <code>NSURLSessionConfiguration</code>遵循<code>&lt;NSURLSessionTaskDelegate&gt;</code>, <code>&lt;NSURLSessionDataDelegate&gt;</code>, <code>&lt;NSURLSessionDownloadDelegate&gt;</code>, <code>&lt;NSURLSessionDelegate&gt;</code>协议.</p>
<h4 id="创建一个下载任务"><a href="#创建一个下载任务" class="headerlink" title="创建一个下载任务"></a>创建一个下载任务</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</div><div class="line">    <span class="built_in">NSURL</span> *documentsDirectoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">NO</span> error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];</div><div class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</div><div class="line">&#125;];</div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure>
<h4 id="创建一个上传任务"><a href="#创建一个上传任务" class="headerlink" title="创建一个上传任务"></a>创建一个上传任务</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/upload"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="built_in">NSURL</span> *filePath = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.png"</span>];</div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask = [manager uploadTaskWithRequest:request fromFile:filePath progress:<span class="literal">nil</span> completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Success: %@ %@"</span>, response, responseObject);</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<h4 id="创建一个多表单请求的上传任务，带进度条"><a href="#创建一个多表单请求的上传任务，带进度条" class="headerlink" title="创建一个多表单请求的上传任务，带进度条"></a>创建一个多表单请求的上传任务，带进度条</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableURLRequest</span> *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:<span class="string">@"POST"</span> URLString:<span class="string">@"http://example.com/upload"</span> parameters:<span class="literal">nil</span> constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;</div><div class="line">        [formData appendPartWithFileURL:[<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.jpg"</span>] name:<span class="string">@"file"</span> fileName:<span class="string">@"filename.jpg"</span> mimeType:<span class="string">@"image/jpeg"</span> error:<span class="literal">nil</span>];</div><div class="line">    &#125; error:<span class="literal">nil</span>];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask;</div><div class="line">uploadTask = [manager</div><div class="line">              uploadTaskWithStreamedRequest:request</div><div class="line">              progress:^(<span class="built_in">NSProgress</span> * _Nonnull uploadProgress) &#123;</div><div class="line">                  <span class="comment">// This is not called back on the main queue.</span></div><div class="line">                  <span class="comment">// You are responsible for dispatching to the main queue for UI updates</span></div><div class="line">                  <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                      <span class="comment">//Update the progress view</span></div><div class="line">                      [progressView setProgress:uploadProgress.fractionCompleted];</div><div class="line">                  &#125;);</div><div class="line">              &#125;</div><div class="line">              completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">                  <span class="keyword">if</span> (error) &#123;</div><div class="line">                      <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">                  &#125; <span class="keyword">else</span> &#123;</div><div class="line">                      <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">                  &#125;</div><div class="line">              &#125;];</div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<h4 id="创建一个数据任务"><a href="#创建一个数据任务" class="headerlink" title="创建一个数据任务"></a>创建一个数据任务</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://httpbin.org/get"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *dataTask = [manager dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line">[dataTask resume];</div></pre></td></tr></table></figure>
<hr>
<h3 id="请求序列化"><a href="#请求序列化" class="headerlink" title="请求序列化"></a>请求序列化</h3><p>请求序列化器通过将参数编码为字符串或HTTP请求体，结合URL字符串创建一个请求。</p>
<h4 id="字符串格式的参数编码"><a href="#字符串格式的参数编码" class="headerlink" title="字符串格式的参数编码"></a>字符串格式的参数编码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[AFHTTPRequestSerializer serializer] requestWithMethod:<span class="string">@"GET"</span> URLString:URLString parameters:parameters error:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<blockquote>
<p>GET <a href="http://example.com?foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3" target="_blank" rel="external">http://example.com?foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3</a></p>
</blockquote>
<h4 id="URL格式的参数编码"><a href="#URL格式的参数编码" class="headerlink" title="URL格式的参数编码"></a>URL格式的参数编码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[AFHTTPRequestSerializer serializer] requestWithMethod:<span class="string">@"POST"</span> URLString:URLString parameters:parameters error:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<blockquote>
<p>POST <a href="http://example.com/" target="_blank" rel="external">http://example.com/</a><br>Content-Type: application/x-www-form-urlencoded<br>foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3</p>
</blockquote>
<h4 id="JSON格式的参数编码"><a href="#JSON格式的参数编码" class="headerlink" title="JSON格式的参数编码"></a>JSON格式的参数编码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[AFJSONRequestSerializer serializer] requestWithMethod:<span class="string">@"POST"</span> URLString:URLString parameters:parameters error:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<blockquote>
<p>POST <a href="http://example.com/" target="_blank" rel="external">http://example.com/</a><br>Content-Type: application/json<br>{“foo”: “bar”, “baz”: [1,2,3]}</p>
</blockquote>
<h3 id="网络可达性管理"><a href="#网络可达性管理" class="headerlink" title="网络可达性管理"></a>网络可达性管理</h3><p>AFNetworkReachabilityManager监控WWAN和WiFi的网络可达性。</p>
<ul>
<li>不要使用Reachability决定是否发送原始请求；<ul>
<li>应该尝试重发。</li>
</ul>
</li>
<li>可以使用Reachability决定一个请求在什么时候自动重发；<ul>
<li>虽然可能请求失败，但一个网络可达的Reachability通知是重新请求某些事物的好时候。</li>
</ul>
</li>
<li>网络可达管理器是个很有用的工具，可以确定一个请求为什么失败。<ul>
<li>一个网络请求失败后，通知用户“断线了”，比返回“请求超时”这种更技术更精确的错误要好。</li>
</ul>
</li>
</ul>
<p>参考 <a href="https://developer.apple.com/videos/play/wwdc2012-706/" target="_blank" rel="external">WWDC 2012 session 706, “Networking Best Practices.”</a>.</p>
<h4 id="共享的网络可达性管理器"><a href="#共享的网络可达性管理器" class="headerlink" title="共享的网络可达性管理器"></a>共享的网络可达性管理器</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reachability: %@"</span>, AFStringFromNetworkReachabilityStatus(status));</div><div class="line">&#125;];</div><div class="line">[[AFNetworkReachabilityManager sharedManager] startMonitoring];</div></pre></td></tr></table></figure>
<h3 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h3><p>在你的APP里添加pinned X.509证书会帮你避免人为攻击和其他漏洞扫描。当应用处理敏感的用户数据或金融信息时，非常需要在具有SSL证书的HTTPS连接中执行所有操作。</p>
<p>####允许无效SSL证书</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line">manager.securityPolicy.allowInvalidCertificates = <span class="literal">YES</span>; <span class="comment">// not recommended for production</span></div></pre></td></tr></table></figure>
]]></content:encoded>
      
      <comments>gofee.me/2017/01/25/AFNetworking-translate/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用 Face++ 实现人脸识别</title>
      <link>gofee.me/2016/11/30/face-recognition-02/</link>
      <guid>gofee.me/2016/11/30/face-recognition-02/</guid>
      <pubDate>Wed, 30 Nov 2016 09:37:43 GMT</pubDate>
      <description>
      
        &lt;p&gt;上次讲了如何&lt;a href=&quot;/2016/11/22/face-recognition-01/&quot; title=&quot;使用Face++实现人脸搜索&quot;&gt;使用Face++实现人脸搜索&lt;/a&gt;，这次我们来谈谈面部识别的实现方法。&lt;/p&gt;
&lt;h3 id=&quot;效果图&quot;&gt;&lt;a href=&quot;#效
      
      </description>
      
      <content:encoded><![CDATA[<p>上次讲了如何<a href="/2016/11/22/face-recognition-01/" title="使用Face++实现人脸搜索">使用Face++实现人脸搜索</a>，这次我们来谈谈面部识别的实现方法。</p>
<h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><img src="/2016/11/30/face-recognition-02/人脸识别.gif" alt="效果图" title="效果图">
<p>将Face++集成到项目中详细步骤请参考<a href="/2016/11/22/face-recognition-01/" title="使用 Face++实现人脸搜索">使用 Face++实现人脸搜索</a>第一部分。</p>
<h4 id="开始工作"><a href="#开始工作" class="headerlink" title="开始工作"></a>开始工作</h4><h5 id="1-声明属性变量"><a href="#1-声明属性变量" class="headerlink" title="1. 声明属性变量"></a>1. 声明属性变量</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>) <span class="built_in">UIImage</span> personImg;<span class="comment">//人物图像</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>) IBOutletUIImageView *imgView;</div></pre></td></tr></table></figure>
<h5 id="2-从本地相册选取图片"><a href="#2-从本地相册选取图片" class="headerlink" title="2. 从本地相册选取图片"></a>2. 从本地相册选取图片</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">UIImagePickerController</span> *picker = [[<span class="built_in">UIImagePickerController</span> alloc] init]; </div><div class="line">picker.sourceType = <span class="built_in">UIImagePickerControllerSourceTypePhotoLibrary</span>; picker.delegate = <span class="keyword">self</span>; </div><div class="line">[<span class="keyword">self</span> presentViewController:picker animated:<span class="literal">YES</span> completion:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<h5 id="3-选择图片后，进行面部识别"><a href="#3-选择图片后，进行面部识别" class="headerlink" title="3. 选择图片后，进行面部识别"></a>3. 选择图片后，进行面部识别</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)imagePickerController:(<span class="built_in">UIImagePickerController</span> *)picker didFinishPickingMediaWithInfo:(<span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *,<span class="keyword">id</span>&gt; *)info&#123;</div><div class="line">    _personImg = info[<span class="built_in">UIImagePickerControllerOriginalImage</span>];</div><div class="line">    [_imgView updateH:_imgView.width / (_personImg.size.width / _personImg.size.height)];<span class="comment">//按原比例更新视图宽高，类别方法，此处就不赘述了</span></div><div class="line">    _imgView.image = _personImg;</div><div class="line">    <span class="built_in">NSData</span> *data = <span class="built_in">UIImageJPEGRepresentation</span>(_personImg, <span class="number">1</span>);</div><div class="line">    </div><div class="line">    <span class="comment">//进行人脸识别，由于耗费时间较长，最好异步执行</span></div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, <span class="number">0</span>), ^&#123;</div><div class="line">        FaceppResult *result = [[FaceppAPI detection] detectWithURL:<span class="literal">nil</span> orImageData:data mode:FaceppDetectionModeOneFace attribute:FaceppDetectionAttributeAll tag:<span class="literal">nil</span> async:<span class="literal">NO</span> others:<span class="literal">nil</span>];</div><div class="line">        <span class="comment">//回到主线程更新UI</span></div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [<span class="keyword">self</span> didFinishDetection:result];</div><div class="line">        &#125;);</div><div class="line">    &#125;);</div><div class="line">    [picker dismissViewControllerAnimated:<span class="literal">YES</span> completion:^&#123;</div><div class="line">        </div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>result返回值说明，JSON示例</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">&#123;<span class="string">"face"</span>: [</div><div class="line">    &#123;<span class="string">"attribute"</span>: &#123;</div><div class="line">        <span class="string">"age"</span>: &#123;<span class="comment">//包含年龄分析结果，value的值为一个非负整数表示估计的年龄, range表示估计年龄的正负区间</span></div><div class="line">            <span class="string">"range"</span>: <span class="number">5</span>,</div><div class="line">            <span class="string">"value"</span>: <span class="number">14</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">"gender"</span>: &#123;<span class="comment">//包含性别分析结果，value的值为Male/Female, confidence表示置信度</span></div><div class="line">            <span class="string">"confidence"</span>: <span class="number">99.9981</span>,</div><div class="line">            <span class="string">"value"</span>: <span class="string">"Female"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">"race"</span>: &#123;<span class="comment">//包含人种分析结果，value的值为Asian/White/Black, confidence表示置信度</span></div><div class="line">            <span class="string">"confidence"</span>: <span class="number">99.818</span>,</div><div class="line">            <span class="string">"value"</span>: <span class="string">"Asian"</span></div><div class="line">        &#125;,</div><div class="line">        <span class="string">"smiling"</span>: &#123;<span class="comment">//包含微笑程度分析结果，value的值为0－100的实数，越大表示微笑程度越高</span></div><div class="line">            <span class="string">"value"</span>: <span class="number">8.14031</span></div><div class="line">        &#125;</div><div class="line">    &#125;,</div><div class="line">      <span class="string">"face_id"</span>: <span class="string">"62bed8c94bbf92323675943328aed269"</span>,</div><div class="line">      <span class="string">"position"</span>: &#123;</div><div class="line">          <span class="string">"center"</span>: &#123;<span class="comment">//检出的人脸框的中心点坐标, x &amp; y 坐标分别表示在图片中的宽度和高度的百分比 (0~100之间的实数)</span></div><div class="line">              <span class="string">"x"</span>: <span class="number">49.731183</span>,</div><div class="line">              <span class="string">"y"</span>: <span class="number">32.5</span></div><div class="line">          &#125;,</div><div class="line">          <span class="string">"eye_left"</span>: &#123;<span class="comment">//相应人脸的左眼坐标，x &amp; y 坐标分别表示在图片中的宽度和高度的百分比 (0~100之间的实数)</span></div><div class="line">              <span class="string">"x"</span>: <span class="number">43.148441</span>,</div><div class="line">              <span class="string">"y"</span>: <span class="number">28.722909</span></div><div class="line">          &#125;,</div><div class="line">          <span class="string">"eye_right"</span>: &#123;<span class="comment">//相应人脸的右眼坐标，x &amp; y 坐标分别表示在图片中的宽度和高度的百分比 (0~100之间的实数)</span></div><div class="line">              <span class="string">"x"</span>: <span class="number">55.413441</span>,</div><div class="line">              <span class="string">"y"</span>: <span class="number">27.745455</span></div><div class="line">          &#125;,</div><div class="line">          <span class="string">"height"</span>: <span class="number">21.363636</span>, <span class="comment">//0~100之间的实数，表示检出的脸的高度在图片中百分比</span></div><div class="line">          <span class="string">"mouth_left"</span>: &#123;<span class="comment">//相应人脸的左侧嘴角坐标，x &amp; y 坐标分别表示在图片中的宽度和高度的百分比 (0~100之间的实数)</span></div><div class="line">              <span class="string">"x"</span>: <span class="number">46.193978</span>,</div><div class="line">              <span class="string">"y"</span>: <span class="number">39.472682</span></div><div class="line">          &#125;,</div><div class="line">          <span class="string">"mouth_right"</span>: &#123;<span class="comment">//相应人脸的右侧嘴角坐标，x &amp; y 坐标分别表示在图片中的宽度和高度的百分比 (0~100之间的实数)</span></div><div class="line">              <span class="string">"x"</span>: <span class="number">54.952688</span>,</div><div class="line">              <span class="string">"y"</span>: <span class="number">38.989955</span></div><div class="line">          &#125;,</div><div class="line">          <span class="string">"nose"</span>: &#123;<span class="comment">//相应人脸的鼻尖坐标，x &amp; y 坐标分别表示在图片中的宽度和高度的百分比 (0~100之间的实数)</span></div><div class="line">              <span class="string">"x"</span>: <span class="number">50.23414</span>,                    </div><div class="line">              <span class="string">"y"</span>: <span class="number">34.953727</span>                </div><div class="line">          &#125;,                </div><div class="line">          <span class="string">"width"</span>: <span class="number">25.268817</span> <span class="comment">//0~100之间的实数，表示检出的脸的宽度在图片中百分比            </span></div><div class="line">      &#125;,            </div><div class="line">      <span class="string">"tag"</span>: <span class="string">""</span>        </div><div class="line">    &#125;],</div><div class="line">    <span class="string">"img_height"</span>: <span class="number">220</span>,</div><div class="line">    <span class="string">"img_id"</span>: <span class="string">"064aae142ef977bb44b6cc3dd9a6eeb1"</span>,    </div><div class="line">    <span class="string">"img_width"</span>: <span class="number">186</span>,    </div><div class="line">    <span class="string">"session_id"</span>: <span class="string">"ade961e7b0d347ca943e0f0f752f7cc5"</span>,    </div><div class="line">    <span class="string">"url"</span>: null</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="4-对检测结果进行处理"><a href="#4-对检测结果进行处理" class="headerlink" title="4. 对检测结果进行处理"></a>4. 对检测结果进行处理</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)didFinishDetection:(FaceppResult *)result&#123;</div><div class="line">    <span class="built_in">NSDictionary</span> *face = [result content][<span class="string">@"face"</span>][<span class="number">0</span>];</div><div class="line">    [<span class="keyword">self</span> markTheFiveSenseOrgansWithData:face];</div><div class="line">    [<span class="keyword">self</span> markFaceWithData:face];</div><div class="line">    [<span class="keyword">self</span> analysisPersonWithData:face];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>1) 标记脸部范围</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)markFaceWithData:(<span class="built_in">NSDictionary</span> *)face&#123;</div><div class="line">    <span class="built_in">CGFloat</span> img_width = _imgView.frame.size.width;</div><div class="line">    <span class="built_in">CGFloat</span> img_height = _imgView.frame.size.height;</div><div class="line">    <span class="built_in">CGFloat</span> center_x = [face[<span class="string">@"position"</span>][<span class="string">@"center"</span>][<span class="string">@"x"</span>] floatValue] / <span class="number">100.</span>f * img_width;<span class="comment">//脸部中心点x坐标</span></div><div class="line">    <span class="built_in">CGFloat</span> center_y = [face[<span class="string">@"position"</span>][<span class="string">@"center"</span>][<span class="string">@"y"</span>] floatValue] / <span class="number">100.</span>f * img_height;<span class="comment">//脸部中心点y坐标</span></div><div class="line">    <span class="built_in">CGFloat</span> width = [face[<span class="string">@"position"</span>][<span class="string">@"width"</span>] floatValue] / <span class="number">100.</span>f * img_width;<span class="comment">//脸部宽度</span></div><div class="line">    <span class="built_in">CGFloat</span> height = [face[<span class="string">@"position"</span>][<span class="string">@"height"</span>] floatValue] / <span class="number">100.</span>f * img_height;<span class="comment">//脸部高度</span></div><div class="line">    <span class="built_in">CGPoint</span> center = <span class="built_in">CGPointMake</span>(center_x, center_y);    </div><div class="line">    <span class="built_in">CGRect</span> rect = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height);</div><div class="line">    <span class="comment">//自定义一个CALayer,画一个矩形</span></div><div class="line">    RectLayer *rectLayer = [RectLayer layer];</div><div class="line">    rectLayer.bounds = rect;</div><div class="line">    rectLayer.position = center;</div><div class="line">    [rectLayer setNeedsDisplayInRect:rect];</div><div class="line">    [<span class="keyword">self</span>.imgView.layer addSublayer:rectLayer];     <span class="comment">//自定义一个CALayer,画一个矩形</span></div><div class="line">    [rectLayer twinkleAnimation:<span class="number">3</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2) 标记五官</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)markTheFiveSenseOrgansWithData:(<span class="built_in">NSDictionary</span> *)face&#123;</div><div class="line">    <span class="built_in">CGFloat</span> img_width = _imgView.frame.size.width;</div><div class="line">    <span class="built_in">CGFloat</span> img_height = _imgView.frame.size.height;</div><div class="line">    <span class="built_in">CGFloat</span> eye_left_x = [face[<span class="string">@"position"</span>][<span class="string">@"eye_left"</span>][<span class="string">@"x"</span>] floatValue] / <span class="number">100.</span>f * img_width;</div><div class="line">    <span class="built_in">CGFloat</span> eye_left_y = [face[<span class="string">@"position"</span>][<span class="string">@"eye_left"</span>][<span class="string">@"y"</span>] floatValue] / <span class="number">100.</span>f * img_height;</div><div class="line">    <span class="built_in">CGFloat</span> eye_right_x = [face[<span class="string">@"position"</span>][<span class="string">@"eye_right"</span>][<span class="string">@"x"</span>] floatValue] / <span class="number">100.</span>f * img_width;</div><div class="line">    <span class="built_in">CGFloat</span> eye_right_y = [face[<span class="string">@"position"</span>][<span class="string">@"eye_right"</span>][<span class="string">@"y"</span>] floatValue] / <span class="number">100.</span>f * img_height;</div><div class="line">    <span class="built_in">CGFloat</span> mouth_left_x = [face[<span class="string">@"position"</span>][<span class="string">@"mouth_left"</span>][<span class="string">@"x"</span>] floatValue] / <span class="number">100.</span>f * img_width;</div><div class="line">    <span class="built_in">CGFloat</span> mouth_left_y = [face[<span class="string">@"position"</span>][<span class="string">@"mouth_left"</span>][<span class="string">@"y"</span>] floatValue] / <span class="number">100.</span>f * img_height;</div><div class="line">    <span class="built_in">CGFloat</span> mouth_right_x = [face[<span class="string">@"position"</span>][<span class="string">@"mouth_right"</span>][<span class="string">@"x"</span>] floatValue] / <span class="number">100.</span>f * img_width;</div><div class="line">    <span class="built_in">CGFloat</span> mouth_right_y = [face[<span class="string">@"position"</span>][<span class="string">@"mouth_right"</span>][<span class="string">@"y"</span>] floatValue] / <span class="number">100.</span>f * img_height;</div><div class="line">    <span class="built_in">CGFloat</span> nose_x = [face[<span class="string">@"position"</span>][<span class="string">@"nose"</span>][<span class="string">@"x"</span>] floatValue] / <span class="number">100.</span>f * img_width;</div><div class="line">    <span class="built_in">CGFloat</span> nose_y = [face[<span class="string">@"position"</span>][<span class="string">@"nose"</span>][<span class="string">@"y"</span>] floatValue] / <span class="number">100.</span>f * img_height;</div><div class="line">    <span class="comment">//标注左眼</span></div><div class="line">    <span class="built_in">CALayer</span> *leftEyeLayer = [<span class="built_in">CALayer</span> layer];</div><div class="line">    leftEyeLayer.frame = <span class="built_in">CGRectMake</span>(eye_left_x, eye_left_y, <span class="number">2</span>, <span class="number">2</span>);</div><div class="line">    leftEyeLayer.backgroundColor = [<span class="built_in">UIColor</span> greenColor].CGColor;</div><div class="line">    [leftEyeLayer setNeedsDisplay];</div><div class="line">    [<span class="keyword">self</span>.imgView.layer addSublayer:leftEyeLayer];</div><div class="line">    </div><div class="line">    <span class="comment">//标注右眼    CALayer *rightEyeLayer = [CALayer layer];</span></div><div class="line">    rightEyeLayer.frame = <span class="built_in">CGRectMake</span>(eye_right_x, eye_right_y, <span class="number">2</span>, <span class="number">2</span>);</div><div class="line">    rightEyeLayer.backgroundColor = [<span class="built_in">UIColor</span> greenColor].CGColor;</div><div class="line">    [rightEyeLayer setNeedsDisplay];</div><div class="line">    [<span class="keyword">self</span>.imgView.layer addSublayer:rightEyeLayer];</div><div class="line">    [leftEyeLayer twinkleAnimation:<span class="number">3</span>];</div><div class="line">    [rightEyeLayer twinkleAnimation:<span class="number">3</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//标注鼻子</span></div><div class="line">    RoundLayer *noseLayer = [RoundLayer layer];</div><div class="line">    noseLayer.bounds = <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">20</span>, <span class="number">20</span>);</div><div class="line">    noseLayer.position = <span class="built_in">CGPointMake</span>(nose_x, nose_y);</div><div class="line">    [noseLayer setNeedsDisplay];</div><div class="line">    [<span class="keyword">self</span>.imgView.layer addSublayer:noseLayer];</div><div class="line">    [noseLayer twinkleAnimation:<span class="number">3</span>];</div><div class="line">    </div><div class="line">    <span class="comment">//标注嘴巴</span></div><div class="line">    RectLayer *mouthLayer = [RectLayer layer];</div><div class="line">    mouthLayer.frame = <span class="built_in">CGRectMake</span>(mouth_left_x, mouth_left_y, mouth_right_x - mouth_left_x, mouth_right_y - mouth_left_y);</div><div class="line">    [mouthLayer setNeedsDisplay];</div><div class="line">    [<span class="keyword">self</span>.imgView.layer addSublayer:mouthLayer];</div><div class="line">    [mouthLayer twinkleAnimation:<span class="number">3</span>];</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>3) 分析人物特征</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">- (<span class="keyword">void</span>)analysisPersonWithData:(<span class="built_in">NSDictionary</span> *)face&#123;</div><div class="line">    <span class="built_in">CGFloat</span> smiling = [face[<span class="string">@"attribute"</span>][<span class="string">@"smiling"</span>][<span class="string">@"value"</span>] floatValue];<span class="comment">//笑容</span></div><div class="line">    <span class="built_in">NSInteger</span> age_value = [face[<span class="string">@"attribute"</span>][<span class="string">@"age"</span>][<span class="string">@"value"</span>] integerValue];<span class="comment">//年龄</span></div><div class="line">    <span class="built_in">NSInteger</span> age_range = [face[<span class="string">@"attribute"</span>][<span class="string">@"age"</span>][<span class="string">@"range"</span>] integerValue];<span class="comment">//年龄误差</span></div><div class="line">    <span class="built_in">NSString</span> *gender = face[<span class="string">@"attribute"</span>][<span class="string">@"gender"</span>][<span class="string">@"value"</span>];<span class="comment">//性别</span></div><div class="line">    <span class="built_in">NSString</span> *race = face[<span class="string">@"attribute"</span>][<span class="string">@"race"</span>][<span class="string">@"value"</span>];<span class="comment">//种族</span></div><div class="line">    <span class="built_in">NSArray</span> *texts = @[[<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"开心度：%@"</span>, @(smiling).stringValue],</div><div class="line">                       [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"年龄：%ld - %ld"</span>,age_value - age_range, age_value + age_range],</div><div class="line">                       [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"性别：%@"</span>, gender],</div><div class="line">                       [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"种族：%@"</span>, race]];</div><div class="line">    <span class="built_in">CGFloat</span> width = <span class="keyword">self</span>.view.width - <span class="number">40</span>;</div><div class="line">    <span class="built_in">CGFloat</span> height = <span class="number">20</span>;</div><div class="line">    <span class="built_in">CGFloat</span> x = <span class="number">20</span>;</div><div class="line">    <span class="built_in">CGFloat</span> margin = <span class="number">10</span>;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</div><div class="line">        <span class="built_in">CGFloat</span> y = _imgView.height + _imgView.y + height * i + margin * (i + <span class="number">1</span>);</div><div class="line">        <span class="built_in">UILabel</span> *label = [[<span class="built_in">UILabel</span> alloc] initWithFrame:<span class="built_in">CGRectMake</span>(x, y, width, height)];</div><div class="line">        label.text = texts[i];</div><div class="line">        [<span class="keyword">self</span>.view addSubview:label];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="5-自定义layer"><a href="#5-自定义layer" class="headerlink" title="5. 自定义layer"></a>5. 自定义layer</h5><p>1）RectLayer重写drawInContext方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)drawInContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</div><div class="line">    <span class="comment">//1.绘制图形</span></div><div class="line">    <span class="comment">//画一个矩形</span></div><div class="line">    <span class="built_in">CGContextAddRect</span>(ctx, <span class="keyword">self</span>.bounds);</div><div class="line">    <span class="comment">//设置属性（颜色）</span></div><div class="line">    <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">2</span>);</div><div class="line">    <span class="built_in">CGContextSetRGBStrokeColor</span>(ctx, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    <span class="comment">//2.渲染</span></div><div class="line">    <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>2）RoundLayer重写drawInContext方法</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">-(<span class="keyword">void</span>)drawInContext:(<span class="built_in">CGContextRef</span>)ctx&#123;</div><div class="line">    <span class="built_in">CGContextAddEllipseInRect</span>(ctx, <span class="keyword">self</span>.bounds);</div><div class="line">    <span class="built_in">CGContextSetLineWidth</span>(ctx, <span class="number">2</span>);</div><div class="line">    <span class="built_in">CGContextSetRGBStrokeColor</span>(ctx, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>);</div><div class="line">    <span class="built_in">CGContextStrokePath</span>(ctx);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h5 id="6-创建CALayer类别，管理layer动画"><a href="#6-创建CALayer类别，管理layer动画" class="headerlink" title="6. 创建CALayer类别，管理layer动画"></a>6. 创建CALayer类别，管理layer动画</h5><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"CALayer+Animation.h"</span></span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">CALayer</span> (<span class="title">Animation</span>)</span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)twinkleAnimation:(<span class="keyword">float</span>)time&#123;</div><div class="line">    <span class="built_in">CABasicAnimation</span> *animation = [<span class="built_in">CABasicAnimation</span> animationWithKeyPath:<span class="string">@"opacity"</span>];</div><div class="line">    animation.fromValue = @[@<span class="number">1.0</span>f];</div><div class="line">    animation.toValue = @[@<span class="number">0.0</span>f];</div><div class="line">    animation.autoreverses = <span class="literal">YES</span>;</div><div class="line">    animation.duration = time * <span class="number">0.1</span>;</div><div class="line">    animation.repeatCount = time - <span class="number">1</span>;</div><div class="line">    animation.removedOnCompletion = <span class="literal">NO</span>;</div><div class="line">    animation.fillMode = kCAFillModeForwards;</div><div class="line">    [<span class="keyword">self</span> addAnimation:animation forKey:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></td></tr></table></figure>
]]></content:encoded>
      
      <comments>gofee.me/2016/11/30/face-recognition-02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>使用 Face++ 实现人脸搜索</title>
      <link>gofee.me/2016/11/22/face-recognition-01/</link>
      <guid>gofee.me/2016/11/22/face-recognition-01/</guid>
      <pubDate>Tue, 22 Nov 2016 09:12:25 GMT</pubDate>
      <description>
      
        &lt;p&gt;Face++由三位85后的清华师兄弟于2011年创建，先后获得联想之星的天使投资和创新工场的A轮投资。2013年底开始，先后在世界最权威的人脸检测(FDDB评测)、人脸关键点定位（300-W评测），和人脸识别(LFW评测)获得三个世界第一。这意味着在人脸技术三个最核心的技术
      
      </description>
      
      <content:encoded><![CDATA[<p>Face++由三位85后的清华师兄弟于2011年创建，先后获得联想之星的天使投资和创新工场的A轮投资。2013年底开始，先后在世界最权威的人脸检测(FDDB评测)、人脸关键点定位（300-W评测），和人脸识别(LFW评测)获得三个世界第一。这意味着在人脸技术三个最核心的技术模块，Face++都达到了世界最高水平。同时Face++所提供的技术云平台(Face++ 最好的免费人脸识别云服务)也是世界上最大的人脸技术平台，累计处理图片总数接近10亿规模，并为阿里，联想，360，世纪佳缘，美图秀秀，camera360等一批国内外著名互联网企业提供了技术服务。</p>
<p>在今年6月份的WWDC主题演讲大会上，苹果介绍了一项全新的人脸识别功能。这项功能被添加在 iOS 10 的照片应用当中，会根据面部表情对照片进行分类。苹果软件工程高级副总裁克雷格·费德里奇在演讲中表示，“先进计算机视觉”（Advanced Computer Vision）是今年照片应用最大幅度的一次更新，因为苹果通过深度学习技术将人脸识别带到了 iPhone 身上。</p>
<img src="/2016/11/22/face-recognition-01/IMG_0093.JPG" alt="photos" title="photos">
<p>本文将介绍如何通过Face++来实现人脸搜索。</p>
<img src="/2016/11/22/face-recognition-01/搜索示例.gif" alt="search demo" title="search demo">
<h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>1. 请到GitHub上下载SDK：<a href="https://github.com/FacePlusPlus/facepp-ios-sdk" target="_blank" rel="external">facepp-ios-sdk</a></p>
<p>2. 解压后可以看到两个目录：FaceppSDK和FaceppSDK_ARC。顾名思义，FaceppSDK_ARC是在ARC环境下使用的，FaceppSDK是在MRC环境下使用的，本文着重介绍ARC环境的实现方法。</p>
<p>3. 在Finder中，将FaceppSDK_ARC目录拖入工程目录下，将FaceppSDK_ARC添加至您的工程中;</p>
<p>4. 在应用程序入口处添加以下代码：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"FaceppAPI.h"</span>`</span></div></pre></td></tr></table></figure>
<p>在入口代码中添加如下代码:</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#import <span class="meta-string">"FaceppAPI.h"</span></span></div><div class="line">- (<span class="built_in">BOOL</span>)application:(<span class="built_in">UIApplication</span> *)application didFinishLaunchingWithOptions:(<span class="built_in">NSDictionary</span> *)launchOptions &#123;</div><div class="line">	[FaceppAPI initWithApiKey: <span class="string">@"YOUR_KEY"</span> andApiSecret: <span class="string">@"YOUR_SECRET"</span>];</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>5. 使用调试模式：</p>
<p>开启调试模式之后，程序将向控制台输出所有http请求的url，以及返回json的原始数据，以供调试使用。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[FaceppAPI setDebugMode: <span class="literal">TRUE</span>];</div></pre></td></tr></table></figure>
<p>###开始工作</p>
<p>1. 使用<code>/detection/detect</code>接口来对图片进行检测，在获得数据以后其将返回一个FaceppResult结构</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FaceppResult *result = [[FaceppAPI detection] detectWithURL:<span class="literal">nil</span> </div><div class="line">                        imageData:[<span class="built_in">NSData</span> dataWithContentsOfFile:<span class="string">@"LOCAL_FILE_PATH"</span>]];</div></pre></td></tr></table></figure>
<p>2. 从FaceppResult中获取结果</p>
<p>获得第一张脸的face_id：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSString</span> *face_id = [result content][<span class="string">@"face"</span>][<span class="number">0</span>][<span class="string">@"face_id"</span>];</div></pre></td></tr></table></figure>
<p>3. 对所有图片执行1~2步后，把每个图片对应的face_id存入数组，然后使用<code>/faceset/create</code>接口来创建faceset</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">FaceppResult *setResult = [[FaceppAPI faceset] createWithFacesetName:<span class="literal">nil</span> andFaceId:_facesIds andTag:<span class="string">@"1"</span>];</div><div class="line"><span class="built_in">NSString</span> *faceset_id = [setResult content][<span class="string">@"faceset_id"</span>];</div></pre></td></tr></table></figure>
<p>4. 针对search功能对一个faceset进行训练</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[FaceppAPI train] trainAsynchronouslyWithId:_faceset_id orName:<span class="literal">nil</span> andType:FaceppTrainSearch];</div></pre></td></tr></table></figure>
<p>在一个faceset内进行search之前，必须先对该faceset进行Train。</p>
<p>5. train成功后，针对某张图片的face_id进行搜索</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">FaceppResult *searchResult = [[FaceppAPI recognition] searchWithKeyFaceId:face_id andFacesetId:_faceset_id orFacesetName:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p>搜索到的相似图片的face_id都存储在<code>[searchResult content][@&quot;candidate&quot;]</code>里，以下为运行结果：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"> [FacePlusPlus]response JSON: </div><div class="line">&#123;</div><div class="line">    <span class="string">"candidate"</span>: [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"face_id"</span>: <span class="string">"589bb6f9c7cd98a45c662a93f4607316"</span>, </div><div class="line">            <span class="string">"similarity"</span>: <span class="number">99.9909</span>, </div><div class="line">            <span class="string">"tag"</span>: <span class="string">""</span></div><div class="line">        &#125;, </div><div class="line">        &#123;</div><div class="line">            <span class="string">"face_id"</span>: <span class="string">"4aa39ac1c989ff1e597dafa8979446be"</span>, </div><div class="line">            <span class="string">"similarity"</span>: <span class="number">75.3242</span>, </div><div class="line">            <span class="string">"tag"</span>: <span class="string">""</span></div><div class="line">        &#125;, </div><div class="line">        &#123;</div><div class="line">            <span class="string">"face_id"</span>: <span class="string">"6ae11866cf062abb1908087b7467a03a"</span>, </div><div class="line">            <span class="string">"similarity"</span>: <span class="number">59.9056</span>, </div><div class="line">            <span class="string">"tag"</span>: <span class="string">""</span></div><div class="line">        &#125;</div><div class="line">    ], </div><div class="line">    <span class="string">"session_id"</span>: <span class="string">"e37308bb0e354c75b87fdf1de9b7e5c7"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
]]></content:encoded>
      
      <comments>gofee.me/2016/11/22/face-recognition-01/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vImage学习笔记——卷积（Convolution）</title>
      <link>gofee.me/2016/08/31/vImage-translation-02/</link>
      <guid>gofee.me/2016/08/31/vImage-translation-02/</guid>
      <pubDate>Wed, 31 Aug 2016 08:44:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;em&gt;卷积（Convolution）&lt;/em&gt;是一个常用的图像处理技术，可以改变像素强度，从而影响周围其他像素的强度。卷积的常用技术是创建滤镜，使用卷积技术，你可以获取一些流行的图像效果，比如模糊（blur）、锐化（sharpen）及边缘检测（edge detection
      
      </description>
      
      <content:encoded><![CDATA[<p><em>卷积（Convolution）</em>是一个常用的图像处理技术，可以改变像素强度，从而影响周围其他像素的强度。卷积的常用技术是创建滤镜，使用卷积技术，你可以获取一些流行的图像效果，比如模糊（blur）、锐化（sharpen）及边缘检测（edge detection），这些效果在Photo Booth、iPhoto和Aperture都有广泛使用。</p>
<p>如果你对图像滤镜和实时处理有兴趣的话，你会发现vImage函数集的好处。用图像滤镜，卷积操作可以完成一些常用的滤镜效果，比如浮雕、模糊及色调分离。</p>
<p>vImage卷积技术对锐化或增强图像质量也很有用。当处理一些科学图像时，增强图像质量很有用。此外，由于科学图像通常都很大，就很有必要使用这些vImage技术来达到合适的性能需求。这种情况下你需要用到的技术有边缘检测（edge detection）、锐化、描绘外观轮廓（surface contour outlining）、平滑、及动作检测（motion detection）。</p>
<p>本章节讲述了卷积技术，以及如何使用vImage提供的卷积函数。通过本文，你可以：</p>
<ul>
<li>了解卷积技术可以实现哪些效果；</li>
<li>学习什么是卷积核以及如何构建卷积核；</li>
<li>通过代码示例，学习如何对一个图像使用卷积技术。</li>
</ul>
<h2 id="卷积核（Convolution-Kernels）"><a href="#卷积核（Convolution-Kernels）" class="headerlink" title="卷积核（Convolution Kernels）"></a>卷积核（Convolution Kernels）</h2><p>图1展示了一个图像通过vImage卷积函数添加了浮雕效果前后的对比图。为了达到这个效果，vImage使用一个类网格的数学概念，称为核（kernel），来完成卷积操作。</p>
<p><strong>图1    浮雕</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/emboss.jpg" alt="图1    浮雕" title="图1    浮雕"></p>
<p>图2是一个3×3的kernel。kernel的高度和宽度不必一样，但必须是奇数。kernel内部的数值会影响卷积的整体效果。这些数值决定了初始图像像素会如何转换成目标图像像素，这看起来可能不是很直观，9个数字会如何影响到滤镜效果呢？卷积技术经过一系列的操作，根据周围像素的强度改变当前像素的强度。vImage根据kernel执行卷积操作，这种通过kernel执行卷积计算的过程就称为kernel convolution（核卷积）。</p>
<p><strong>图2    3×3卷积</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/kernel.jpg" alt=""></p>
<p>卷积是像素单位的操作，即对每个像素都要执行同样的算法。因此，大图像比小图像需要更多的卷积操作。一个kernel可以被看做一个二维的网格数据，而图像也可以被看做一个二维网格数据（如图3），对一个图像应用kernel可以想象成把一个小格子（kernel）平铺在大格子（图像）上。</p>
<p><strong>图3    图像是二维网格数据</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/pixels_grid.jpg" alt=""></p>
<p>kernel内部的数值会作为与它下面的数值相乘的乘数，下面的数值指的是被kernel数值覆盖的像素的强度。在进行卷积计算时，把kernel的中心值覆盖在待转换的像素上，然后将kernel的每个值与其正下方的像素值相乘，最后将所有的结果相加，相加后的结果就是新的像素强度。图4展示了kernel是如何转化像素的。</p>
<p><strong>图4    核卷积</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/kernel_convolution.jpg" alt=""></p>
<p>虽然kernel会覆盖到一些其它的像素，但是最终只有kernel中心值正下方的原始像素会发生变化。kernel和图像之间所有乘积相加后的和被称为加权和。为了确保处理后的图像对比原图不会过于饱和，vImage有一个常用的方法，就是设置一个除数因子，把加权和进行拆分。因为用周围像素的加权和来代替原始像素时常导致像素强度过大（并且图像整体也过于明亮），拆分加权和可以按比例降低滤镜效果的强度，并确保维持原始亮度，这个过程称为标准化。这个行为是可选的，被拆分后的加权和会代替原始像素值。kernel对每个像素重复这个过程。</p>
<pre><code>注：如果要执行标准化，你必须向卷积函数提供你要使用的因子。因子最好是2的幂次方。你也可以在图像像素值为整数的时候再提供因子。浮点型不需要使用，因为你可以直接依比例决定kernel的浮点型数值来达到标准化。
</code></pre><p>kernel的数据类型和图像的数据类型必须保持一致，比如，如果图像像素数据类型是浮点型，那么kernel中的数据类型也必须是浮点型。</p>
<p>记住以上所述的算法vImage都已经帮你做好了，你不需要牢记卷积算法的步骤。当然，你也可以在自定义的核中实现该算法。</p>
<h2 id="反卷积"><a href="#反卷积" class="headerlink" title="反卷积"></a>反卷积</h2><p>反卷积指的是解除先前的卷积效果——一般是原始图像中物理携带的卷积效果，比如镜头中的衍射效果。通常，反卷积是一个锐化操作。</p>
<p>反卷积的算法比较多，vImage用的是Richardson-Lucy deconvolution算法。</p>
<p>Richardson-Lucy deconvolution算法的目标是根据卷积后的像素值找到原始的像素值，以及kernel数据。</p>
<p>基于以上需求，在使用反卷积函数时必须提供卷积后的图像及卷积使用的kernel值。</p>
<p>vImage会自行处理反卷积的每一步操作，因此不需要牢记这些步骤。使用反卷积的时候，必须提供初始的卷积kernel（如果该kernel不对称的话，还要额外提供一个对角线翻转的kernel2）。</p>
<h2 id="使用卷积核"><a href="#使用卷积核" class="headerlink" title="使用卷积核"></a>使用卷积核</h2><p>现在你最好了解一下核的结构以及卷积的处理过程，是时候使用几个vImage函数来看看了。本章节展示了如何实现图1中的浮雕效果，并解释了无偏差卷积和带偏差卷积之间的差别。</p>
<h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>vImage可以自动进行卷积计算，而你的工作是提供kernel，即描述卷积应该生成什么效果。表1展示了如何使用卷积去生成浮雕效果。你也可以通过合适的kernel，利用同样的代码来生成一个不同的效果，比如锐化。</p>
<p><strong>表1</strong>　生成浮雕效果</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> myEmboss(<span class="keyword">void</span> *inData,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> inRowBytes,</div><div class="line"> <span class="keyword">void</span> *outData,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> outRowBytes,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> height,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> width,</div><div class="line"> <span class="keyword">void</span> *kernel,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> kernel_height,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> kernel_width,</div><div class="line"> <span class="keyword">int</span> divisor ,</div><div class="line"> vImage_Flags flags )</div><div class="line">&#123;</div><div class="line">    uint_8 kernel = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// 1</span></div><div class="line">    vImage_Buffer src = &#123; inData, height, width, inRowBytes &#125;; <span class="comment">// 2</span></div><div class="line">    vImage_Buffer dest = &#123; outData, height, width, outRowBytes &#125;; <span class="comment">// 3</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bgColor[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;; <span class="comment">// 4</span></div><div class="line">    vImage_Error err; <span class="comment">// 5</span></div><div class="line"> </div><div class="line"> </div><div class="line">    err = vImageConvolve_ARGB8888(    &amp;src,     <span class="comment">//const vImage_Buffer *src</span></div><div class="line">                                        &amp;dest,    <span class="comment">//const vImage_Buffer *dest,</span></div><div class="line">                                        <span class="literal">NULL</span>,</div><div class="line">                                        <span class="number">0</span>,    <span class="comment">//unsigned int srcOffsetToROI_X,</span></div><div class="line">                                        <span class="number">0</span>,    <span class="comment">//unsigned int srcOffsetToROI_Y,</span></div><div class="line">                                        kernel,    <span class="comment">//const signed int *kernel,</span></div><div class="line">                                        kernel_height,     <span class="comment">//unsigned int</span></div><div class="line">                                        kernel_width,    <span class="comment">//unsigned int</span></div><div class="line">                                        divisor,    <span class="comment">//int</span></div><div class="line">                                        bgColor,</div><div class="line">                                       flags | kvImageBackgroundColorFill</div><div class="line">                                       <span class="comment">//vImage_Flags flags</span></div><div class="line">                                    );</div><div class="line"> </div><div class="line"> </div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码都做了哪些工作呢？</p>
<ol>
<li>声明一个浮雕kernel，即int型数组。kernel的数据类型要与相应的vImage函数所需数据类型相匹配。示例中使用了<em>vImageConvolve_ARGB8888</em>函数，因此kernel的数据类型应该是<em>uint_8</em>（无符号，8-bit，整数）。kernel的数组元素从左至右，依次是第一行、第二行、第三行；</li>
<li>声明一个<em>vImage_Buffer</em>变量，用来存储原始图像信息。图像数据以数组的形式进行存储，元素图像二进制数据(<em>inData</em>)，另外还存储高度、宽度和每行的字节数。这样vImage会知道要处理的图像大小，并如何合适地处理它。</li>
<li>声明一个<em>vImage_Buffer</em>变量，用来存储目标图像信息。</li>
<li>声明一个<em>Pixel8888-</em>格式的像素来表示目标图像的背景色（示例中用的是黑色）。</li>
<li>声明一个<em>vImage_Err</em>变量来存储卷积函数的返回值。</li>
</ol>
<p>然后，将这些声明的变量值传入<em>vImageConvolve_ARGB8888</em>函数中，由vImage来处理后续的计算，并把结果存储到<em>dest</em>变量中。<em>vImageConvolve_ARGB8888</em>函数是vImage中仅有的几个卷积函数之一。通常，vImage会为每种图像格式提供4种函数变体，ARGB8888前缀表示该函数处理的是交叉型图像（full-color），每个像素由四个8字节的整数构成一组，代表alpha（A），red（R），green（G）和blue（B）四个通道。想了解vImage支持的图像格式的更多细节，请看<a href="/2016/08/22/vImage-translation-01/" title="vImage概述">vImage概述</a>。</p>
<p>示例<em>myEmboss</em>中还使用了<em>vImage_Flags</em>参数。该参数由1个或多个flags（用或逻辑运算符 | 连接）组成。<em>kvImageBackgroundColorFill</em>表示vImage要使用预先提供的背景色。</p>
<p>为了熟悉kernel效果的使用方法，请在你自己的代码中使用以下两个kernel。图6的kernel可以生成高斯模糊效果，图7的kernel可以生成边缘检测效果。</p>
<p><strong>图6  高斯模糊</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/kernel_gaus.jpg" alt=""></p>
<p><strong>图7  边缘检测</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/kernel_edge.jpg" alt=""></p>
<h3 id="带偏差的卷积"><a href="#带偏差的卷积" class="headerlink" title="带偏差的卷积"></a>带偏差的卷积</h3><p>在执行卷积操作时，可以选择是否带偏差。偏差是指在卷积结果上再额外添加一个来自周围像素的影响。由于某些卷积计算得到的结果可能为负值，偏差可以避免信号溢出。可以把偏差设为127或128，来允许负值也被描绘出来。偏差可能使整体图像效果变亮或变暗。</p>
<p>每个标准的vImage函数（比如<em>vImageConvolve_PlanarF</em>）都有一个对应的带偏差的函数（<em>vImageConvolveWithBias_PlanarF</em>）。偏差函数的使用方法和无偏差函数一样，除了必须设置<em>bias</em>参数来使用偏差。<em>bias</em>的数据类型必须与图像像素数据类型一致。</p>
<p><strong>图8　带偏差与无偏差</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/kernel_biased.jpg" alt=""></p>
<h3 id="使用高速滤镜"><a href="#使用高速滤镜" class="headerlink" title="使用高速滤镜"></a>使用高速滤镜</h3><p>vImage提供了一些特定的卷积函数，这些比一般的卷积函数具有更快的处理速度。OS X v10.4以上的系统，对于<em>Planar_8</em>和<em>ARGB8888</em>数据类型可以使用box滤镜和tent滤镜。这些滤镜可以得到模糊效果，函数是根据他们在笛卡尔坐标系的形状命名的。调用这些函数不需要提供kernel，效果等同于需要提供kernel的一般的卷积函数。但是这些函数比一般的函数性能上要快大约1个量级。</p>
<pre><code>注：由于这些函数需要一个稳健精确的算法，vImage规定这些函数不支持浮点型。浮点型的计算误差会导致图像高密度区域附近的低密度区域显得人工化或粗糙化。
</code></pre><p>box滤镜用周围像素的未加权的平均数来代替被处理的像素值，相当于通过所有值都为1的kernel来进行卷积处理。对应的函数是<em>vImageBoxConvolve_Planar8</em>和<em>vImageBoxConvolve_ARGB8888</em>。每个转换后的像素都是其周围像素的平均值（周围像素的宽、高即kernel的宽、高）。</p>
<p><strong>图9　box滤镜</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/box_filter.jpg" alt=""></p>
<p>tent滤镜用周围像素的加权平均值来代替被处理的像素值。对应的函数是<em>vImageTentConvolve_Planar8</em>和<em>vImageTentConvolve_ARGB8888</em>。tent滤镜的模糊操作相当于使用值不为1的kernel进行的卷积操作。和<em>vImageBoxConvolve_Planar8</em>和<em>vImageBoxConvolve_ARGB8888</em>一样，不需要向函数提供kernel值，只需要宽高即可。</p>
<p><strong>图10　tent滤镜</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/tent_filter.jpg" alt=""></p>
<p>假设kernel的大小是3×5。那么第一个矩阵是</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/vimage_matrix11.gif" alt=""></p>
<p>第二个矩阵是</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/vimage_matrix12.gif" alt=""></p>
<p>那么生成的kernel是</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/vimage_matrix13.gif" alt=""></p>
<p>3×5的tent滤镜操作相当于使用上图中的滤镜来进行卷积操作。</p>
<h3 id="使用多核"><a href="#使用多核" class="headerlink" title="使用多核"></a>使用多核</h3><p>vImage允许在单个卷积操作中使用多个kernel。可以使用<em>vImageConvolveMultiKernel</em>函数，分别定义四个kernel，每个kernel对应一个图像通道。一个kernel控制一个通道的话，你就可以对图像进行更高级别的处理。例如，你可以利用多核卷积对图像的颜色通道分别重新采样，抵消屏幕上的RGB荧光效果。由于四个kernel可以分别对单个颜色通道进行处理，<em>vImageConvolveMultiKernel</em>函数只能应用于交叉型图像。</p>
<p>这些函数的使用方法与单核卷积函数使用方法相同，唯一不同的是，需要提供一个指针数组，数组中每个元素指向一个kernel地址。</p>
<h2 id="反卷积-1"><a href="#反卷积-1" class="headerlink" title="反卷积"></a>反卷积</h2><p>与卷积计算相同的是，vImage同样在内部封装了反卷积的计算过程，你只需要提供一个kernel即可。表2展示了如何把浮雕效果通过反卷积消除的过程。你可以用同样的代码、合适的kernel去反卷积各种效果（比如模糊效果）。但是不同于卷积操作的是，反卷积函数还需要另一个kernel参数。除非kernel的宽和高相同，否则这个参数不能为<em>NULL</em>。如果kernel的宽和高不相等，必须再提供一个行列反转的kernel。</p>
<p>表2是一段示例代码，描述了如何使用vImage对一个ARGB8888-格式的图像进行反卷积。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> myDeconvolve(<span class="keyword">void</span> *inData,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> inRowBytes,</div><div class="line"> <span class="keyword">void</span> *outData,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> outRowBytes,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> height,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> width,</div><div class="line"> <span class="keyword">void</span> *kernel,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> kernel_height,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> kernel_width,</div><div class="line"> <span class="keyword">int</span> divisor,</div><div class="line"> <span class="keyword">int</span> iterationCount,</div><div class="line"> vImage_Flags flags )</div><div class="line">&#123;</div><div class="line">    <span class="comment">//Prepare data structures</span></div><div class="line">    uint_8 kernel = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// 1</span></div><div class="line">    vImage_Error err; <span class="comment">// 2</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bgColor[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;; <span class="comment">// 3</span></div><div class="line">    vImage_Buffer src = &#123; inData, height, width, inRowBytes &#125;; <span class="comment">// 4</span></div><div class="line">    vImage_Buffer dest = &#123; outData, height, width, outRowBytes &#125;; <span class="comment">// 5</span></div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">    <span class="comment">//Send data to vImage for processing</span></div><div class="line"> </div><div class="line">    err = vImageRichardsonLucyDeConvolve_ARGB8888(    &amp;src,     <span class="comment">// 6</span></div><div class="line">                                        &amp;dest,    <span class="comment">//const vImage_Buffer *dest,</span></div><div class="line">                                        <span class="literal">NULL</span>,</div><div class="line">                                        <span class="number">0</span>,    <span class="comment">//unsigned int srcOffsetToROI_X,</span></div><div class="line">                                        <span class="number">0</span>,    <span class="comment">//unsigned int srcOffsetToROI_Y,</span></div><div class="line">                                        kernel,    <span class="comment">//const signed int *kernel,</span></div><div class="line">                                        <span class="literal">NULL</span>, <span class="comment">//assumes symmetric kernel</span></div><div class="line">                                        kernel_height,     <span class="comment">//unsigned int kernel_height,</span></div><div class="line">                                        kernel_width,    <span class="comment">//unsigned int kernel_width,</span></div><div class="line">                                        <span class="number">0</span>, <span class="comment">//height of second kernel</span></div><div class="line">                                        <span class="number">0</span>, <span class="comment">//width of second kernel</span></div><div class="line">                                        divisor,    <span class="comment">//int</span></div><div class="line">                                        <span class="number">0</span>, <span class="comment">//for second kernel</span></div><div class="line">                                        bgColor,</div><div class="line">                                        iterationCount, <span class="comment">//uint32_t</span></div><div class="line">                                        kvImageBackgroundColorFill | flags</div><div class="line">                                        <span class="comment">//vImage_Flags</span></div><div class="line">                                    );</div><div class="line"> </div><div class="line"> </div><div class="line">    <span class="comment">//Report result</span></div><div class="line">    <span class="keyword">return</span> err; <span class="comment">// 7</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码都做了什么？</p>
<ol>
<li>定义vImage要进行反卷积处理的初始卷积图像的kernel值。示例使用的是对称的kernel（宽高都为3），因此不用再定义第二个kernel；</li>
<li>声明一个<em>vImage_Error</em>结构体，来存储反卷积结果；</li>
<li>声明一个Pixel8888-类型的像素，用于表示转换后图像的背景色；</li>
<li>声明一个<em>vImage_Buffer</em>结构体，用于存储初始图像信息。图像数据是作为一个字节型数组存储的，包括图像数据<em>inData</em>、宽、高、行字节等信息。这些信息可以让vImage知道它要处理的图像有多大，从而更好的执行操作；</li>
<li>声明一个<em>vImage_Buffer</em>结构体，用于存储目标图像信息；</li>
<li>把上述声明的变量传给vImage函数。注意示例中在调用<em>vImageRichardsonDeConvolve_ARGB8888</em>函数时，第二个kernel为<em>NULL</em>，这是因为第一个kernel是对称的，没有必要再进行翻转。</li>
</ol>
<p>反卷积是一个迭代过程。你可以设置迭代次数，次数不同，得到的结果会不一样，因此，为了得到最理想的结果，可以多试几次。</p>
]]></content:encoded>
      
      <comments>gofee.me/2016/08/31/vImage-translation-02/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
