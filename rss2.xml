<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Freya&#39;s blog</title>
    <link>gofee.me/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>灵动，洒脱，决然，坚韧</description>
    <pubDate>Wed, 26 Jul 2017 08:25:31 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>关于storyboard不得不说的事</title>
      <link>gofee.me/2017/05/05/storyboard-loading/</link>
      <guid>gofee.me/2017/05/05/storyboard-loading/</guid>
      <pubDate>Fri, 05 May 2017 03:39:02 GMT</pubDate>
      <description>
      
        &lt;p&gt;自 iOS 5 时代苹果推出 Storyboard（以下简称SB）以来，关于使用代码手写 UI、SB 和 xib 之间的争论就一直存在。问题主要在于 Storyboard 的加载过程是否会影响性能，下面就分析一下 Storyboard 中的 ViewController 是
      
      </description>
      
      <content:encoded><![CDATA[<p>自 iOS 5 时代苹果推出 Storyboard（以下简称SB）以来，关于使用代码手写 UI、SB 和 xib 之间的争论就一直存在。问题主要在于 Storyboard 的加载过程是否会影响性能，下面就分析一下 Storyboard 中的 ViewController 是怎么加载出来的。</p>
<p>细心的同学会发现，在编译的时候 Xcode 有个 Compiling Storyboard files 的过程。编译过程中，项目里用到的 SB 文件也会被编译，并以 <code>.storyboarc</code> 为扩展名最终保存在 APP 包内。<code>.storyboardc</code> 是一个文件夹，里面保存了描述编译后的 SB 信息的 <code>Info.plist</code> 文件，以及一系列 <code>.nib</code> 文件。原来的 SB 中的每个对象（也就是每个 ViewController）将会被编译成一个单独的 <code>.nib</code>，<code>.nib</code> 中包含了编码后的对应的对象层级。在加载一个 SB，并从中读取 ViewController 类型和 nib 的关系，来完成 <code>UIStoryboard</code> 的初始化。接下来读取某个 nib，并使用<code>UINibDecoder</code> 进行解码，将 nib 二进制还原为实际的对象，最后调用该对象的 <code>initWithCoder：</code> 完成各个属性的解码。最后，调用 <code>awakeFromNib</code> 方法，来通知开发者从 nib 的加载已经完毕。</p>
<img src="/2017/05/05/storyboard-loading/storyboard的加载过程.png" alt="Storyboard 的加载过程" title="Storyboard 的加载过程">
<p>可以看出，从只有一个 ViewController 的 SB 中加载这个 VC，与从有多个 ViewController 的 SB 中加载的情况，速度上并不会有什么区别。</p>
<p>原文： <a href="https://onevcat.com/2017/04/storyboard-argue/" target="_blank" rel="external">再看关于 Storyboard 的一些争论</a></p>
]]></content:encoded>
      
      <comments>gofee.me/2017/05/05/storyboard-loading/#disqus_thread</comments>
    </item>
    
    <item>
      <title>AFNetworking README 中文版</title>
      <link>gofee.me/2017/01/25/AFNetworking-translate/</link>
      <guid>gofee.me/2017/01/25/AFNetworking-translate/</guid>
      <pubDate>Wed, 25 Jan 2017 12:23:15 GMT</pubDate>
      <description>
      
        &lt;h1 id=&quot;AFNetworking-README-中文版&quot;&gt;&lt;a href=&quot;#AFNetworking-README-中文版&quot; class=&quot;headerlink&quot; title=&quot;AFNetworking README 中文版&quot;&gt;&lt;/a&gt;AFNetworking READ
      
      </description>
      
      <content:encoded><![CDATA[<h1 id="AFNetworking-README-中文版"><a href="#AFNetworking-README-中文版" class="headerlink" title="AFNetworking README 中文版"></a>AFNetworking README 中文版</h1><p>AFNetworking是iOS和Mac OS X平台上的轻量级网络库，在Foudation URL加载系统基础上构建，对构建于Cocoa的强大高级的网络抽象进行了扩充。它具有设计良好的、富有特性的、模块化结构的API接口集。</p>
<h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><h3 id="NSURLSession-会话"><a href="#NSURLSession-会话" class="headerlink" title="NSURLSession 会话"></a>NSURLSession 会话</h3><ul>
<li>AFURLSessionManager</li>
<li>AFHTTPSessionManager</li>
</ul>
<h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><ul>
<li><afurlrequestserialization><ul>
<li>AFHTTPRequestSerializer</li>
<li>AFJSONRequestSerializer</li>
<li>AFPropertyListRequestSerializer</li>
</ul>
</afurlrequestserialization></li>
<li><afurlresponsesirialization><ul>
<li>AFHTTPResponseSerializer</li>
<li>AFJSONResponseSerializer</li>
<li>AFXMLParserResponseSerializer</li>
<li>AFXMLDocumentResponseSerializer(Mac OS X)</li>
<li>AFPropertyListResponseSerializer</li>
<li>AFImageResponseSerializer</li>
<li>AFCompoundResponseSerializer</li>
</ul>
</afurlresponsesirialization></li>
</ul>
<h3 id="其他功能"><a href="#其他功能" class="headerlink" title="其他功能"></a>其他功能</h3><ul>
<li>AFSecurityPolicy</li>
<li>AFNetworkReachabilityManager</li>
</ul>
<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="AFURLSessionManager"><a href="#AFURLSessionManager" class="headerlink" title="AFURLSessionManager"></a>AFURLSessionManager</h3><p>AFURLSessionManager在一个定义好的NSURLSessionConfiguration对象基础上创建并管理一个NSURLSession对象, NSURLSessionConfiguration遵循<nsurlsessiontaskdelegate>, <nsurlsessiondatadelegate>, <nsurlsessiondownloaddelegate>, <nsurlsessiondelegate>协议.</nsurlsessiondelegate></nsurlsessiondownloaddelegate></nsurlsessiondatadelegate></nsurlsessiontaskdelegate></p>
<h4 id="创建一个下载任务"><a href="#创建一个下载任务" class="headerlink" title="创建一个下载任务"></a>创建一个下载任务</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/download.zip"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="built_in">NSURLSessionDownloadTask</span> *downloadTask = [manager downloadTaskWithRequest:request progress:<span class="literal">nil</span> destination:^<span class="built_in">NSURL</span> *(<span class="built_in">NSURL</span> *targetPath, <span class="built_in">NSURLResponse</span> *response) &#123;</div><div class="line">    <span class="built_in">NSURL</span> *documentsDirectoryURL = [[<span class="built_in">NSFileManager</span> defaultManager] URLForDirectory:<span class="built_in">NSDocumentDirectory</span> inDomain:<span class="built_in">NSUserDomainMask</span> appropriateForURL:<span class="literal">nil</span> create:<span class="literal">NO</span> error:<span class="literal">nil</span>];</div><div class="line">    <span class="keyword">return</span> [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];</div><div class="line">&#125; completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="built_in">NSURL</span> *filePath, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"File downloaded to: %@"</span>, filePath);</div><div class="line">&#125;];</div><div class="line">[downloadTask resume];</div></pre></td></tr></table></figure>
<h4 id="创建一个上传任务"><a href="#创建一个上传任务" class="headerlink" title="创建一个上传任务"></a>创建一个上传任务</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://example.com/upload"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="built_in">NSURL</span> *filePath = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.png"</span>];</div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask = [manager uploadTaskWithRequest:request fromFile:filePath progress:<span class="literal">nil</span> completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Success: %@ %@"</span>, response, responseObject);</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<h4 id="创建一个多表单请求的上传任务，带进度条"><a href="#创建一个多表单请求的上传任务，带进度条" class="headerlink" title="创建一个多表单请求的上传任务，带进度条"></a>创建一个多表单请求的上传任务，带进度条</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSMutableURLRequest</span> *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:<span class="string">@"POST"</span> URLString:<span class="string">@"http://example.com/upload"</span> parameters:<span class="literal">nil</span> constructingBodyWithBlock:^(<span class="keyword">id</span>&lt;AFMultipartFormData&gt; formData) &#123;</div><div class="line">        [formData appendPartWithFileURL:[<span class="built_in">NSURL</span> fileURLWithPath:<span class="string">@"file://path/to/image.jpg"</span>] name:<span class="string">@"file"</span> fileName:<span class="string">@"filename.jpg"</span> mimeType:<span class="string">@"image/jpeg"</span> error:<span class="literal">nil</span>];</div><div class="line">    &#125; error:<span class="literal">nil</span>];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</div><div class="line"><span class="built_in">NSURLSessionUploadTask</span> *uploadTask;</div><div class="line">uploadTask = [manager</div><div class="line">              uploadTaskWithStreamedRequest:request</div><div class="line">              progress:^(<span class="built_in">NSProgress</span> * _Nonnull uploadProgress) &#123;</div><div class="line">                  <span class="comment">// This is not called back on the main queue.</span></div><div class="line">                  <span class="comment">// You are responsible for dispatching to the main queue for UI updates</span></div><div class="line">                  <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                      <span class="comment">//Update the progress view</span></div><div class="line">                      [progressView setProgress:uploadProgress.fractionCompleted];</div><div class="line">                  &#125;);</div><div class="line">              &#125;</div><div class="line">              completionHandler:^(<span class="built_in">NSURLResponse</span> * _Nonnull response, <span class="keyword">id</span>  _Nullable responseObject, <span class="built_in">NSError</span> * _Nullable error) &#123;</div><div class="line">                  <span class="keyword">if</span> (error) &#123;</div><div class="line">                      <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">                  &#125; <span class="keyword">else</span> &#123;</div><div class="line">                      <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">                  &#125;</div><div class="line">              &#125;];</div><div class="line">[uploadTask resume];</div></pre></td></tr></table></figure>
<h4 id="创建一个数据任务"><a href="#创建一个数据任务" class="headerlink" title="创建一个数据任务"></a>创建一个数据任务</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURLSessionConfiguration</span> *configuration = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];</div><div class="line"><span class="built_in">NSURL</span> *URL = [<span class="built_in">NSURL</span> URLWithString:<span class="string">@"http://httpbin.org/get"</span>];</div><div class="line"><span class="built_in">NSURLRequest</span> *request = [<span class="built_in">NSURLRequest</span> requestWithURL:URL];</div><div class="line"><span class="built_in">NSURLSessionDataTask</span> *dataTask = [manager dataTaskWithRequest:request completionHandler:^(<span class="built_in">NSURLResponse</span> *response, <span class="keyword">id</span> responseObject, <span class="built_in">NSError</span> *error) &#123;</div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"Error: %@"</span>, error);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">NSLog</span>(<span class="string">@"%@ %@"</span>, response, responseObject);</div><div class="line">    &#125;</div><div class="line">&#125;];</div><div class="line">[dataTask resume];</div></pre></td></tr></table></figure>
<hr>
<h3 id="请求序列化"><a href="#请求序列化" class="headerlink" title="请求序列化"></a>请求序列化</h3><p>请求序列化器通过将参数编码为字符串或HTTP请求体，结合URL字符串创建一个请求。</p>
<h4 id="字符串格式的参数编码"><a href="#字符串格式的参数编码" class="headerlink" title="字符串格式的参数编码"></a>字符串格式的参数编码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[AFHTTPRequestSerializer serializer] requestWithMethod:<span class="string">@"GET"</span> URLString:URLString parameters:parameters error:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<p><code>GET http://example.com?foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3</code></p>
<h4 id="URL格式的参数编码"><a href="#URL格式的参数编码" class="headerlink" title="URL格式的参数编码"></a>URL格式的参数编码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[AFHTTPRequestSerializer serializer] requestWithMethod:<span class="string">@"POST"</span> URLString:URLString parameters:parameters error:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POST http://example.com/</div><div class="line">Content-Type: application/x-www-form-urlencoded</div><div class="line">foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3</div></pre></td></tr></table></figure>
<h4 id="JSON格式的参数编码"><a href="#JSON格式的参数编码" class="headerlink" title="JSON格式的参数编码"></a>JSON格式的参数编码</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">[[AFJSONRequestSerializer serializer] requestWithMethod:<span class="string">@"POST"</span> URLString:URLString parameters:parameters error:<span class="literal">nil</span>];</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">POST http://example.com/</div><div class="line">Content-Type: application/json</div><div class="line">&#123;&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: [1,2,3]&#125;</div></pre></td></tr></table></figure>
<h3 id="网络可达性管理"><a href="#网络可达性管理" class="headerlink" title="网络可达性管理"></a>网络可达性管理</h3><p>AFNetworkReachabilityManager监控WWAN和WiFi的网络可达性。</p>
<ul>
<li>不要使用Reachability决定是否发送原始请求；<ul>
<li>应该尝试重发。</li>
</ul>
</li>
<li>可以使用Reachability决定一个请求在什么时候自动重发；<ul>
<li>虽然可能请求失败，但一个网络可达的Reachability通知是重新请求某些事物的好时候。</li>
</ul>
</li>
<li>网络可达管理器是个很有用的工具，可以确定一个请求为什么失败。<ul>
<li>一个网络请求失败后，通知用户“断线了”，比返回“请求超时”这种更技术更精确的错误要好。</li>
</ul>
</li>
</ul>
<p>参考 <wwdc 2012="" session="" 706,="" “networking="" best="" practices.”="">(<a href="https://developer.apple.com/videos/play/wwdc2012-706/" target="_blank" rel="external">https://developer.apple.com/videos/play/wwdc2012-706/</a>).</wwdc></p>
<h4 id="共享的网络可达性管理器"><a href="#共享的网络可达性管理器" class="headerlink" title="共享的网络可达性管理器"></a>共享的网络可达性管理器</h4><figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123;</div><div class="line">    <span class="built_in">NSLog</span>(<span class="string">@"Reachability: %@"</span>, AFStringFromNetworkReachabilityStatus(status));</div><div class="line">&#125;];</div><div class="line">[[AFNetworkReachabilityManager sharedManager] startMonitoring];</div></pre></td></tr></table></figure>
<h3 id="安全策略"><a href="#安全策略" class="headerlink" title="安全策略"></a>安全策略</h3><p>在你的APP里添加pinned X.509证书会帮你避免人为攻击和其他漏洞扫描。当应用处理敏感的用户数据或金融信息时，非常需要在具有SSL证书的HTTPS连接中执行所有操作。</p>
<p>####允许无效SSL证书</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];</div><div class="line">manager.securityPolicy.allowInvalidCertificates = <span class="literal">YES</span>; <span class="comment">// not recommended for production</span></div></pre></td></tr></table></figure>
]]></content:encoded>
      
      <comments>gofee.me/2017/01/25/AFNetworking-translate/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vImage学习笔记——卷积（Convolution）</title>
      <link>gofee.me/2016/08/31/vImage-translation-02/</link>
      <guid>gofee.me/2016/08/31/vImage-translation-02/</guid>
      <pubDate>Wed, 31 Aug 2016 08:44:03 GMT</pubDate>
      <description>
      
        &lt;p&gt;&lt;em&gt;卷积（Convolution）&lt;/em&gt;是一个常用的图像处理技术，可以改变像素强度，从而影响周围其他像素的强度。卷积的常用技术是创建滤镜，使用卷积技术，你可以获取一些流行的图像效果，比如模糊（blur）、锐化（sharpen）及边缘检测（edge detection
      
      </description>
      
      <content:encoded><![CDATA[<p><em>卷积（Convolution）</em>是一个常用的图像处理技术，可以改变像素强度，从而影响周围其他像素的强度。卷积的常用技术是创建滤镜，使用卷积技术，你可以获取一些流行的图像效果，比如模糊（blur）、锐化（sharpen）及边缘检测（edge detection），这些效果在Photo Booth、iPhoto和Aperture都有广泛使用。</p>
<p>如果你对图像滤镜和实时处理有兴趣的话，你会发现vImage函数集的好处。用图像滤镜，卷积操作可以完成一些常用的滤镜效果，比如浮雕、模糊及色调分离。</p>
<p>vImage卷积技术对锐化或增强图像质量也很有用。当处理一些科学图像时，增强图像质量很有用。此外，由于科学图像通常都很大，就很有必要使用这些vImage技术来达到合适的性能需求。这种情况下你需要用到的技术有边缘检测（edge detection）、锐化、描绘外观轮廓（surface contour outlining）、平滑、及动作检测（motion detection）。</p>
<p>本章节讲述了卷积技术，以及如何使用vImage提供的卷积函数。通过本文，你可以：</p>
<ul>
<li>了解卷积技术可以实现哪些效果；</li>
<li>学习什么是卷积核以及如何构建卷积核；</li>
<li>通过代码示例，学习如何对一个图像使用卷积技术。</li>
</ul>
<h2 id="卷积核（Convolution-Kernels）"><a href="#卷积核（Convolution-Kernels）" class="headerlink" title="卷积核（Convolution Kernels）"></a>卷积核（Convolution Kernels）</h2><p>图1展示了一个图像通过vImage卷积函数添加了浮雕效果前后的对比图。为了达到这个效果，vImage使用一个类网格的数学概念，称为核（kernel），来完成卷积操作。</p>
<p><strong>图1    浮雕</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/emboss.jpg" alt="图1    浮雕" title="图1    浮雕"></p>
<p>图2是一个3×3的kernel。kernel的高度和宽度不必一样，但必须是奇数。kernel内部的数值会影响卷积的整体效果。这些数值决定了初始图像像素会如何转换成目标图像像素，这看起来可能不是很直观，9个数字会如何影响到滤镜效果呢？卷积技术经过一系列的操作，根据周围像素的强度改变当前像素的强度。vImage根据kernel执行卷积操作，这种通过kernel执行卷积计算的过程就称为kernel convolution（核卷积）。</p>
<p><strong>图2    3×3卷积</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/kernel.jpg" alt=""></p>
<p>卷积是像素单位的操作，即对每个像素都要执行同样的算法。因此，大图像比小图像需要更多的卷积操作。一个kernel可以被看做一个二维的网格数据，而图像也可以被看做一个二维网格数据（如图3），对一个图像应用kernel可以想象成把一个小格子（kernel）平铺在大格子（图像）上。</p>
<p><strong>图3    图像是二维网格数据</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/pixels_grid.jpg" alt=""></p>
<p>kernel内部的数值会作为与它下面的数值相乘的乘数，下面的数值指的是被kernel数值覆盖的像素的强度。在进行卷积计算时，把kernel的中心值覆盖在待转换的像素上，然后将kernel的每个值与其正下方的像素值相乘，最后将所有的结果相加，相加后的结果就是新的像素强度。图4展示了kernel是如何转化像素的。</p>
<p><strong>图4    核卷积</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/kernel_convolution.jpg" alt=""></p>
<p>虽然kernel会覆盖到一些其它的像素，但是最终只有kernel中心值正下方的原始像素会发生变化。kernel和图像之间所有乘积相加后的和被称为加权和。为了确保处理后的图像对比原图不会过于饱和，vImage有一个常用的方法，就是设置一个除数因子，把加权和进行拆分。因为用周围像素的加权和来代替原始像素时常导致像素强度过大（并且图像整体也过于明亮），拆分加权和可以按比例降低滤镜效果的强度，并确保维持原始亮度，这个过程称为标准化。这个行为是可选的，被拆分后的加权和会代替原始像素值。kernel对每个像素重复这个过程。</p>
<pre><code>注：如果要执行标准化，你必须向卷积函数提供你要使用的因子。因子最好是2的幂次方。你也可以在图像像素值为整数的时候再提供因子。浮点型不需要使用，因为你可以直接依比例决定kernel的浮点型数值来达到标准化。
</code></pre><p>kernel的数据类型和图像的数据类型必须保持一致，比如，如果图像像素数据类型是浮点型，那么kernel中的数据类型也必须是浮点型。</p>
<p>记住以上所述的算法vImage都已经帮你做好了，你不需要牢记卷积算法的步骤。当然，你也可以在自定义的核中实现该算法。</p>
<h2 id="反卷积"><a href="#反卷积" class="headerlink" title="反卷积"></a>反卷积</h2><p>反卷积指的是解除先前的卷积效果——一般是原始图像中物理携带的卷积效果，比如镜头中的衍射效果。通常，反卷积是一个锐化操作。</p>
<p>反卷积的算法比较多，vImage用的是Richardson-Lucy deconvolution算法。</p>
<p>Richardson-Lucy deconvolution算法的目标是根据卷积后的像素值找到原始的像素值，以及kernel数据。</p>
<p>基于以上需求，在使用反卷积函数时必须提供卷积后的图像及卷积使用的kernel值。</p>
<p>vImage会自行处理反卷积的每一步操作，因此不需要牢记这些步骤。使用反卷积的时候，必须提供初始的卷积kernel（如果该kernel不对称的话，还要额外提供一个对角线翻转的kernel2）。</p>
<h2 id="使用卷积核"><a href="#使用卷积核" class="headerlink" title="使用卷积核"></a>使用卷积核</h2><p>现在你最好了解一下核的结构以及卷积的处理过程，是时候使用几个vImage函数来看看了。本章节展示了如何实现图1中的浮雕效果，并解释了无偏差卷积和带偏差卷积之间的差别。</p>
<h3 id="卷积"><a href="#卷积" class="headerlink" title="卷积"></a>卷积</h3><p>vImage可以自动进行卷积计算，而你的工作是提供kernel，即描述卷积应该生成什么效果。表1展示了如何使用卷积去生成浮雕效果。你也可以通过合适的kernel，利用同样的代码来生成一个不同的效果，比如锐化。</p>
<p><strong>表1</strong>　生成浮雕效果</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> myEmboss(<span class="keyword">void</span> *inData,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> inRowBytes,</div><div class="line"> <span class="keyword">void</span> *outData,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> outRowBytes,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> height,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> width,</div><div class="line"> <span class="keyword">void</span> *kernel,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> kernel_height,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> kernel_width,</div><div class="line"> <span class="keyword">int</span> divisor ,</div><div class="line"> vImage_Flags flags )</div><div class="line">&#123;</div><div class="line">    uint_8 kernel = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// 1</span></div><div class="line">    vImage_Buffer src = &#123; inData, height, width, inRowBytes &#125;; <span class="comment">// 2</span></div><div class="line">    vImage_Buffer dest = &#123; outData, height, width, outRowBytes &#125;; <span class="comment">// 3</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bgColor[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;; <span class="comment">// 4</span></div><div class="line">    vImage_Error err; <span class="comment">// 5</span></div><div class="line"> </div><div class="line"> </div><div class="line">    err = vImageConvolve_ARGB8888(    &amp;src,     <span class="comment">//const vImage_Buffer *src</span></div><div class="line">                                        &amp;dest,    <span class="comment">//const vImage_Buffer *dest,</span></div><div class="line">                                        <span class="literal">NULL</span>,</div><div class="line">                                        <span class="number">0</span>,    <span class="comment">//unsigned int srcOffsetToROI_X,</span></div><div class="line">                                        <span class="number">0</span>,    <span class="comment">//unsigned int srcOffsetToROI_Y,</span></div><div class="line">                                        kernel,    <span class="comment">//const signed int *kernel,</span></div><div class="line">                                        kernel_height,     <span class="comment">//unsigned int</span></div><div class="line">                                        kernel_width,    <span class="comment">//unsigned int</span></div><div class="line">                                        divisor,    <span class="comment">//int</span></div><div class="line">                                        bgColor,</div><div class="line">                                       flags | kvImageBackgroundColorFill</div><div class="line">                                       <span class="comment">//vImage_Flags flags</span></div><div class="line">                                    );</div><div class="line"> </div><div class="line"> </div><div class="line">    <span class="keyword">return</span> err;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码都做了哪些工作呢？</p>
<ol>
<li>声明一个浮雕kernel，即int型数组。kernel的数据类型要与相应的vImage函数所需数据类型相匹配。示例中使用了<em>vImageConvolve_ARGB8888</em>函数，因此kernel的数据类型应该是<em>uint_8</em>（无符号，8-bit，整数）。kernel的数组元素从左至右，依次是第一行、第二行、第三行；</li>
<li>声明一个<em>vImage_Buffer</em>变量，用来存储原始图像信息。图像数据以数组的形式进行存储，元素图像二进制数据(<em>inData</em>)，另外还存储高度、宽度和每行的字节数。这样vImage会知道要处理的图像大小，并如何合适地处理它。</li>
<li>声明一个<em>vImage_Buffer</em>变量，用来存储目标图像信息。</li>
<li>声明一个<em>Pixel8888-</em>格式的像素来表示目标图像的背景色（示例中用的是黑色）。</li>
<li>声明一个<em>vImage_Err</em>变量来存储卷积函数的返回值。</li>
</ol>
<p>然后，将这些声明的变量值传入<em>vImageConvolve_ARGB8888</em>函数中，由vImage来处理后续的计算，并把结果存储到<em>dest</em>变量中。<em>vImageConvolve_ARGB8888</em>函数是vImage中仅有的几个卷积函数之一。通常，vImage会为每种图像格式提供4种函数变体，ARGB8888前缀表示该函数处理的是交叉型图像（full-color），每个像素由四个8字节的整数构成一组，代表alpha（A），red（R），green（G）和blue（B）四个通道。想了解vImage支持的图像格式的更多细节，请看<a href="/2016/08/22/vImage-translation-01/" title="vImage概述">vImage概述</a><a href="vImage学习笔记.mdown">vImage概述</a></p>
<p>示例<em>myEmboss</em>中还使用了<em>vImage_Flags</em>参数。该参数由1个或多个flags（用或逻辑运算符 | 连接）组成。<em>kvImageBackgroundColorFill</em>表示vImage要使用预先提供的背景色。</p>
<p>为了熟悉kernel效果的使用方法，请在你自己的代码中使用以下两个kernel。图6的kernel可以生成高斯模糊效果，图7的kernel可以生成边缘检测效果。</p>
<p><strong>图6  高斯模糊</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/kernel_gaus.jpg" alt=""></p>
<p><strong>图7  边缘检测</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/kernel_edge.jpg" alt=""></p>
<h3 id="带偏差的卷积"><a href="#带偏差的卷积" class="headerlink" title="带偏差的卷积"></a>带偏差的卷积</h3><p>在执行卷积操作时，可以选择是否带偏差。偏差是指在卷积结果上再额外添加一个来自周围像素的影响。由于某些卷积计算得到的结果可能为负值，偏差可以避免信号溢出。可以把偏差设为127或128，来允许负值也被描绘出来。偏差可能使整体图像效果变亮或变暗。</p>
<p>每个标准的vImage函数（比如<em>vImageConvolve_PlanarF</em>）都有一个对应的带偏差的函数（<em>vImageConvolveWithBias_PlanarF</em>）。偏差函数的使用方法和无偏差函数一样，除了必须设置<em>bias</em>参数来使用偏差。<em>bias</em>的数据类型必须与图像像素数据类型一致。</p>
<p><strong>图8　带偏差与无偏差</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/kernel_biased.jpg" alt=""></p>
<h3 id="使用高速滤镜"><a href="#使用高速滤镜" class="headerlink" title="使用高速滤镜"></a>使用高速滤镜</h3><p>vImage提供了一些特定的卷积函数，这些比一般的卷积函数具有更快的处理速度。OS X v10.4以上的系统，对于<em>Planar_8</em>和<em>ARGB8888</em>数据类型可以使用box滤镜和tent滤镜。这些滤镜可以得到模糊效果，函数是根据他们在笛卡尔坐标系的形状命名的。调用这些函数不需要提供kernel，效果等同于需要提供kernel的一般的卷积函数。但是这些函数比一般的函数性能上要快大约1个量级。</p>
<pre><code>注：由于这些函数需要一个稳健精确的算法，vImage规定这些函数不支持浮点型。浮点型的计算误差会导致图像高密度区域附近的低密度区域显得人工化或粗糙化。
</code></pre><p>box滤镜用周围像素的未加权的平均数来代替被处理的像素值，相当于通过所有值都为1的kernel来进行卷积处理。对应的函数是<em>vImageBoxConvolve_Planar8</em>和<em>vImageBoxConvolve_ARGB8888</em>。每个转换后的像素都是其周围像素的平均值（周围像素的宽、高即kernel的宽、高）。</p>
<p><strong>图9　box滤镜</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/box_filter.jpg" alt=""></p>
<p>tent滤镜用周围像素的加权平均值来代替被处理的像素值。对应的函数是<em>vImageTentConvolve_Planar8</em>和<em>vImageTentConvolve_ARGB8888</em>。tent滤镜的模糊操作相当于使用值不为1的kernel进行的卷积操作。和<em>vImageBoxConvolve_Planar8</em>和<em>vImageBoxConvolve_ARGB8888</em>一样，不需要向函数提供kernel值，只需要宽高即可。</p>
<p><strong>图10　tent滤镜</strong></p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/tent_filter.jpg" alt=""></p>
<p>假设kernel的大小是3×5。那么第一个矩阵是</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/vimage_matrix11.gif" alt=""></p>
<p>第二个矩阵是</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/vimage_matrix12.gif" alt=""></p>
<p>那么生成的kernel是</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Performance/Conceptual/vImage/Art/vimage_matrix13.gif" alt=""></p>
<p>3×5的tent滤镜操作相当于使用上图中的滤镜来进行卷积操作。</p>
<h3 id="使用多核"><a href="#使用多核" class="headerlink" title="使用多核"></a>使用多核</h3><p>vImage允许在单个卷积操作中使用多个kernel。可以使用<em>vImageConvolveMultiKernel</em>函数，分别定义四个kernel，每个kernel对应一个图像通道。一个kernel控制一个通道的话，你就可以对图像进行更高级别的处理。例如，你可以利用多核卷积对图像的颜色通道分别重新采样，抵消屏幕上的RGB荧光效果。由于四个kernel可以分别对单个颜色通道进行处理，<em>vImageConvolveMultiKernel</em>函数只能应用于交叉型图像。</p>
<p>这些函数的使用方法与单核卷积函数使用方法相同，唯一不同的是，需要提供一个指针数组，数组中每个元素指向一个kernel地址。</p>
<h2 id="反卷积-1"><a href="#反卷积-1" class="headerlink" title="反卷积"></a>反卷积</h2><p>与卷积计算相同的是，vImage同样在内部封装了反卷积的计算过程，你只需要提供一个kernel即可。表2展示了如何把浮雕效果通过反卷积消除的过程。你可以用同样的代码、合适的kernel去反卷积各种效果（比如模糊效果）。但是不同于卷积操作的是，反卷积函数还需要另一个kernel参数。除非kernel的宽和高相同，否则这个参数不能为<em>NULL</em>。如果kernel的宽和高不相等，必须再提供一个行列反转的kernel。</p>
<p>表2是一段示例代码，描述了如何使用vImage对一个ARGB8888-格式的图像进行反卷积。</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> myDeconvolve(<span class="keyword">void</span> *inData,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> inRowBytes,</div><div class="line"> <span class="keyword">void</span> *outData,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> outRowBytes,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> height,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> width,</div><div class="line"> <span class="keyword">void</span> *kernel,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> kernel_height,</div><div class="line"> <span class="keyword">unsigned</span> <span class="keyword">int</span> kernel_width,</div><div class="line"> <span class="keyword">int</span> divisor,</div><div class="line"> <span class="keyword">int</span> iterationCount,</div><div class="line"> vImage_Flags flags )</div><div class="line">&#123;</div><div class="line">    <span class="comment">//Prepare data structures</span></div><div class="line">    uint_8 kernel = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">0</span>, <span class="number">-2</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;; <span class="comment">// 1</span></div><div class="line">    vImage_Error err; <span class="comment">// 2</span></div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> bgColor[<span class="number">4</span>] = &#123; <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span> &#125;; <span class="comment">// 3</span></div><div class="line">    vImage_Buffer src = &#123; inData, height, width, inRowBytes &#125;; <span class="comment">// 4</span></div><div class="line">    vImage_Buffer dest = &#123; outData, height, width, outRowBytes &#125;; <span class="comment">// 5</span></div><div class="line"> </div><div class="line"> </div><div class="line"> </div><div class="line">    <span class="comment">//Send data to vImage for processing</span></div><div class="line"> </div><div class="line">    err = vImageRichardsonLucyDeConvolve_ARGB8888(    &amp;src,     <span class="comment">// 6</span></div><div class="line">                                        &amp;dest,    <span class="comment">//const vImage_Buffer *dest,</span></div><div class="line">                                        <span class="literal">NULL</span>,</div><div class="line">                                        <span class="number">0</span>,    <span class="comment">//unsigned int srcOffsetToROI_X,</span></div><div class="line">                                        <span class="number">0</span>,    <span class="comment">//unsigned int srcOffsetToROI_Y,</span></div><div class="line">                                        kernel,    <span class="comment">//const signed int *kernel,</span></div><div class="line">                                        <span class="literal">NULL</span>, <span class="comment">//assumes symmetric kernel</span></div><div class="line">                                        kernel_height,     <span class="comment">//unsigned int kernel_height,</span></div><div class="line">                                        kernel_width,    <span class="comment">//unsigned int kernel_width,</span></div><div class="line">                                        <span class="number">0</span>, <span class="comment">//height of second kernel</span></div><div class="line">                                        <span class="number">0</span>, <span class="comment">//width of second kernel</span></div><div class="line">                                        divisor,    <span class="comment">//int</span></div><div class="line">                                        <span class="number">0</span>, <span class="comment">//for second kernel</span></div><div class="line">                                        bgColor,</div><div class="line">                                        iterationCount, <span class="comment">//uint32_t</span></div><div class="line">                                        kvImageBackgroundColorFill | flags</div><div class="line">                                        <span class="comment">//vImage_Flags</span></div><div class="line">                                    );</div><div class="line"> </div><div class="line"> </div><div class="line">    <span class="comment">//Report result</span></div><div class="line">    <span class="keyword">return</span> err; <span class="comment">// 7</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段代码都做了什么？</p>
<ol>
<li>定义vImage要进行反卷积处理的初始卷积图像的kernel值。示例使用的是对称的kernel（宽高都为3），因此不用再定义第二个kernel；</li>
<li>声明一个<em>vImage_Error</em>结构体，来存储反卷积结果；</li>
<li>声明一个Pixel8888-类型的像素，用于表示转换后图像的背景色；</li>
<li>声明一个<em>vImage_Buffer</em>结构体，用于存储初始图像信息。图像数据是作为一个字节型数组存储的，包括图像数据<em>inData</em>、宽、高、行字节等信息。这些信息可以让vImage知道它要处理的图像有多大，从而更好的执行操作；</li>
<li>声明一个<em>vImage_Buffer</em>结构体，用于存储目标图像信息；</li>
<li>把上述声明的变量传给vImage函数。注意示例中在调用<em>vImageRichardsonDeConvolve_ARGB8888</em>函数时，第二个kernel为<em>NULL</em>，这是因为第一个kernel是对称的，没有必要再进行翻转。</li>
</ol>
<p>反卷积是一个迭代过程。你可以设置迭代次数，次数不同，得到的结果会不一样，因此，为了得到最理想的结果，可以多试几次。</p>
]]></content:encoded>
      
      <comments>gofee.me/2016/08/31/vImage-translation-02/#disqus_thread</comments>
    </item>
    
    <item>
      <title>vImage学习笔记（一）——概述</title>
      <link>gofee.me/2016/08/22/vImage-translation-01/</link>
      <guid>gofee.me/2016/08/22/vImage-translation-01/</guid>
      <pubDate>Mon, 22 Aug 2016 08:43:58 GMT</pubDate>
      <description>
      
        &lt;h2 id=&quot;一、关于图像格式-Image-Formats&quot;&gt;&lt;a href=&quot;#一、关于图像格式-Image-Formats&quot; class=&quot;headerlink&quot; title=&quot;一、关于图像格式    Image Formats&quot;&gt;&lt;/a&gt;一、关于图像格式    Image
      
      </description>
      
      <content:encoded><![CDATA[<h2 id="一、关于图像格式-Image-Formats"><a href="#一、关于图像格式-Image-Formats" class="headerlink" title="一、关于图像格式    Image Formats"></a>一、关于图像格式    Image Formats</h2><p>图像格式（Image Formats）规定了像素数据如何在内存中存储。图像文件格式（比如JPG、PNG、GIF等）用来在程序中转换图像数据，并将数据存储在硬盘上。诸如Image I/O等框架可以从硬盘加载各种格式的图像文件，并且在内存中使用。在内存中，图像是通过二维数组来存储像素数据的，图像中的每个像素都对应数组中的一个元素。</p>
<p>图像格式（Image Formats）包含两种类型：二维平面型（planar）和交叉型（interleaved）。二维平面型图像把不同通道的数据存储在不同的缓冲区内，一个典型的平面型图像通常包括red、green、blue和alpha四个通道。交叉型图像把不同通道的数据轮换着存储：ARGBARGBARGB……</p>
<p>图像数据可以是整型（integer）和浮点型（float）。在vImage中，通过一个8位（bit）的无符号整型数值表示色饱和度等级。数值范围0~255，255表示最大色饱和度，0表示无色饱和度。浮点型数值通常从0.0~1.0表示色饱和度。</p>
<p>以下是核心操作使用到的图像格式：</p>
<ul>
<li><strong>Planar8</strong>　　单通道（颜色或alpha）图像。每个像素都是一个8bit的无符号整数，数据类型是Pixel_8</li>
<li><strong>PlanarF</strong>　　单通道（颜色）图像。每个像素都是一个32bit的浮点数，数据类型是Pixel_F</li>
<li><strong>ARGB8888</strong>　　图像包含四个交叉通道，alpha、red、green、blue，顺序固定。每个像素都是一个32位的数组（包含四个8位无符号整数）。数据类型是Pixel_8888</li>
<li><strong>ARGBFFFF</strong>　　图像包含四个交叉通道，alpha、red、green、blue，顺序固定。每个像素都是一个包含四个浮点数的数组。数据类型是Pixel_FFFF</li>
<li><strong>RGBA8888</strong>　　图像包含四个交叉通道，red、green、blue、alpha，顺序固定。每个像素都是一个32位的数组（包含四个8位无符号整数）。数据类型是Pixel_8888</li>
<li><strong>RGBAFFFF</strong>　　图像包含四个交叉通道，red、green、blue、alpha，顺序固定。每个像素都是一个包含四个浮点数的数组。数据类型是Pixel_FFFF</li>
</ul>
<p>可以将其他格式的图像转换为vImage的图像格式。例如，可以通过vImageConvert_16SToF函数将一个16位像素的图像转换为vImage支持的32位像素。下面这些函数可以帮助你在vImage图像格式之间进行转换，也可以把vImage不支持的图像格式转换为vImage格式。</p>
<ul>
<li><strong><em>vImageConvert_16SToF</em></strong>   　　　将一个16位符号整型planar图像格式（或  vImage_Buffer.width=4的interleaved-multiply）缓冲区（ vImage_Buffer ）转换为浮点型数值缓冲区</li>
<li><strong><em>vImageConvert_16UToF</em></strong>    　　将一个16位无符号整型planar图像格式（或  vImage_Buffer.width=4的interleaved-multiply）缓冲区（ vImage_Buffer ）转换为浮点型数值缓冲区</li>
<li><strong><em>ImageConvert_FTo16S</em></strong>    　　将一个浮点型planar图像格式（或  vImage_Buffer.width=4的interleaved-multiply）缓冲区（ vImage_Buffer ）转换为16位符号整型缓冲区</li>
<li><strong><em>vImageConvert_FTo16U</em></strong>    　　将一个浮点型planar图像格式（或  vImage_Buffer.width=4的interleaved-multiply）缓冲区（ vImage_Buffer ）转换为16位无符号整型缓冲区</li>
<li><strong><em>vImageConvert_16UtoPlanar8</em></strong>    　　将一个16位无符号整型planar图像格式（或  vImage_Buffer.width=4的interleaved-multiply）缓冲区（ vImage_Buffer ）转换为8位整型缓冲区</li>
<li><strong><em>vImageConvert_Planar8to16U</em></strong>    　　将一个8位整型planar图像格式（或  vImage_Buffer.width=4的interleaved-multiply）缓冲区（ vImage_Buffer ）转换为16位无符号整型缓冲区</li>
<li><strong><em>vImageConvert_ARGB1555toPlanar8</em></strong>    　　将16位/像素图像（alpha通道1bit，red/green/blue通道5bit）转换为Planar8格式。</li>
<li><strong><em>vImageConvert_ARGB1555toARGB8888</em></strong>    　　将16位/像素图像（alpha通道1bit，red/green/blue通道5bit）转换为ARGB8888格式。</li>
<li><strong><em>vImageConvert_Planar8toARGB1555</em></strong>    　　将Planar8格式图像转换为包含1bit alpha，5bit red，5bit green，5bit blue的16位/像素图像。</li>
<li><strong><em>vImageConvert_ARGB8888toARGB1555</em></strong>    　　将ARGB8888格式图像转换为包含1bit alpha，5bit red，5bit green，5bit blue的16位/像素图像。</li>
<li><strong><em>vImageConvert_RGB565toPlanar8</em></strong>    　　将5bit red，6bit green，5bit blue的16位/像素图像转换为Planar8</li>
<li><strong><em>vImageConvert_RGB565toARGB8888</em></strong>    　　将5bit red，6bit green，5bit blue的16位/像素图像转换为ARGB8888</li>
<li><strong><em>vImageConvert_Planar8toRGB565</em></strong>    　　将Planar8图像转换为5-6-6图像</li>
<li><strong><em>vImageConvert_ARGB8888toRGB565</em></strong>    　　将ARGB8888图像转换为5-6-5图像</li>
<li><strong><em>vImageConvert_Planar16FtoPlanarF</em></strong>    　　将16位浮点型planar图像转换为32位浮点型</li>
</ul>
<h2 id="二、vImage练习"><a href="#二、vImage练习" class="headerlink" title="二、vImage练习"></a>二、vImage练习</h2><h3 id="Loading-Image-Data"><a href="#Loading-Image-Data" class="headerlink" title="Loading Image Data"></a>Loading Image Data</h3><p>要将vImage集成到你的应用中，首先要把raw图像数据加载到内存。可以使用Image I/O框架把任何主流的图像文件（JPG、PNG、GIF等）加载到C类型缓冲池中（void *arrays）。</p>
<p>以下是从本地文件提取raw图像数据的例子：</p>
<figure class="highlight objc"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">NSURL</span>* url = [<span class="built_in">NSURL</span> fileURLWithPath:filename];</div><div class="line"><span class="comment">//Create the image source with the options left null for now</span></div><div class="line"><span class="comment">//Keep in mind since we created it, we're responsible for getting rid of it</span></div><div class="line"><span class="built_in">CGImageSourceRef</span> image_source = <span class="built_in">CGImageSourceCreateWithURL</span>( (<span class="built_in">CFURLRef</span>)url, <span class="literal">NULL</span>);</div><div class="line"><span class="keyword">if</span>(image_source == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//Something went wrong</span></div><div class="line">    fprintf(stderr, <span class="string">"VImage error: Couldn't create image source from URL\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//Now that we got the source, let's create an image from the first image in the CGImageSource</span></div><div class="line"><span class="built_in">CGImageRef</span> image = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(image_source, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line"> </div><div class="line"><span class="comment">//We created our image, and that's all we needed the source for, so let's release it</span></div><div class="line"><span class="built_in">CFRelease</span>(image_source);</div><div class="line"> </div><div class="line"><span class="keyword">if</span>(image == <span class="literal">NULL</span>)</div><div class="line">&#123;</div><div class="line">    <span class="comment">//something went wrong</span></div><div class="line">    fprintf(stderr, <span class="string">"VImage error: Couldn't create image source from URL\n"</span>);</div><div class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>把图像加载到内存之后，就可以通过vImage函数进行各种处理了。请密切注意函数下划线之后的字符，那代表了像素数据的格式。vImage函数既可以在源缓冲区中直接处理，也可以在提供的目标缓冲区中处理。</p>
<p>由于vImage只负责处理图像，你还需要想办法把图像显示出来。根据你的应用开发环境（Carbon or Cocoa），你需要找到一个方法（例如Quartz）去显示合成后的像素数据，或将图像数据存储到磁盘（Image I/O）。</p>
<h4 id="使用二维图像格式"><a href="#使用二维图像格式" class="headerlink" title="使用二维图像格式"></a>使用二维图像格式</h4><p>大多数vImage函数是从四种图像格式开始的。二维图像每次编码一个通道（先存储所有的红色通道数据，然后是绿色，蓝色，alpha），而交叉图像在内存是混合存储所有通道的。</p>
<blockquote>
<p>注意：有时候你可能并不需要处理所有的通道。比如，你知道你要处理的图像中是不需要alpha通道的，或可能你的图像是灰度图，因此你只需要一个通道。这种情况下，使用二维图像格式可以让你把需要的通道隔离出来。</p>
</blockquote>
<h4 id="拼贴（Tiles）技术"><a href="#拼贴（Tiles）技术" class="headerlink" title="拼贴（Tiles）技术"></a>拼贴（Tiles）技术</h4><p>在图像应用中，通常要使用Tiles将一个图像分割成几个小图。之所以称为tiling技术，是因为这看起来很像是把多个地板瓷砖拼接成一大块儿的过程，图像中多个小的单位拼贴在一起，形成一个大的图像。这个技术的优势在于，把数据分散成N个小的单位后，可以分散填充到高速缓存中，这使CPU的处理速度加快了许多。</p>
<p>通常来说，当被处理的数据（包括输入数据和输出数据）放在处理器的数据缓存中时，vImage具有更好的性能。访问处理器缓存中的数据比访问内存数据要快很多。然而CPU缓存是很快，但是它在空间上是有限制的。不同的CPU缓存大小不一样，但总的来说，在Intel处理器中保存少于2MB的tile图像，还有在PowerPC处理器中保存少于512KB的tile还是很有优势的。</p>
<ul>
<li><p>以下是Tiles技术的一些技巧：</p>
<ul>
<li>有些CPU缓存一次只能保存很少量的数据（通常是512KB或更少）<ul>
<li>128KB - 512KB的tile数据吞吐量最优</li>
</ul>
</li>
<li>很多vImage函数内部可以使用tile技术（还有多线程）。如果你想自己控制tiling，可以在调用函数时在flags参数中添加kvImageDoNotTile标记，这样可以避免函数在内部使用tiling或多线程技术。</li>
<li>对于平方形tile，128KB-256KB的tile大小具有最好的吞吐率。</li>
<li>不同函数的最优tile大小也是不同的。具有少量字节计算的函数（大多数是转换函数）在file size 小于16KB时是最快的，典型的vImage函数在256KB tile size下是最快的。</li>
</ul>
</li>
</ul>
<h4 id="数据缓冲排列"><a href="#数据缓冲排列" class="headerlink" title="数据缓冲排列"></a>数据缓冲排列</h4><p>当分配图像的浮点型数据时，保持4个字节的排列是很重要的。这说明你分配的字节数应该是4的整数倍。</p>
<p>以下是数据排列和缓冲区大小的一些技巧：</p>
<ul>
<li>尽管vImage默认可以有更少的数据排列，但为了性能最优化，所有数据都应该是16字节排列，且rowbytes应该是16的整数倍。</li>
<li>浮点型数据必须至少是4字节，否则某些函数可能会报错。</li>
<li>函数的rowBytes参数不能传入2的幂次方。</li>
</ul>
<h4 id="缓冲区（buffer）重用机制"><a href="#缓冲区（buffer）重用机制" class="headerlink" title="缓冲区（buffer）重用机制"></a>缓冲区（buffer）重用机制</h4><p>很多函数在执行任务时，会使用临时缓冲区来存储中间值。在一开始只需创建一次buffer，就可以在多个函数中使用，这样可以节省时间。</p>
<p>如果你没有提供buffer，这些函数会自行创建buffer（当然，使用完后释放）。</p>
<p>如果你只需要调用几次该函数，并且不在意短暂的阻塞，那么让函数自行创建buffer是个明智的选择。</p>
<p>每个使用到临时buffer的函数都有一个src和desc参数（数据类型都是vImage_Buffer）。函数只使用了这些参数的height和width域；忽略data和rowBytes域。</p>
<p>可能的话，应用也应该尝试重用vImage_Buffer数据的data域指向的图像缓冲区。这样可以节省时间，否则还要重新分配并且把原来的buffer抹平。</p>
<p>在实际应用中，要尽可能的避免使用堆和其他可能引起阻塞的操作（比如内存分配）。</p>
<h4 id="适当的使用线程"><a href="#适当的使用线程" class="headerlink" title="适当的使用线程"></a>适当的使用线程</h4><p>vImage是线程安全的并且可重入。如果你分割了你的图像，你可以使用多线程处理不同的tiles。如果你使用不同的处理器处理不同的tiles，你应选择那些水平方向上不相邻的tiles。否则tile的边缘可能会共享到cache，这有可能导致两个处理器之间耗时的干扰。</p>
<p>在vImage函数工作时，vImage的输出buffer状态是未知的。有可能buffer中的像素数据既不是起始数据也不是结束数据，而是计算过程中的一个中间值。</p>
<p>在OS X 10.4之后，一些vImage函数在内部使用了多线程技术。他们自己做了参数检查和多线程来提高性能。vImage维持了它延迟分配线程缓冲池的风格去做这件事。这些线程一旦被创建就不会被销毁，他们会被重用。被调用的线程要等待上一个线程完成自己的任务，在这之前会被阻塞。使用内部实现了多线程技术的函数是安全的。</p>
<p>线程安全的函数通过锁来保持数据一致性。如果你不希望函数使用锁，你需要设置kvImageDoNotTile标志位来阻止vImage使用多线程和tiling技术。如果你设置了该标志位，你的应用需要自行处理数据tiling和多线程。</p>
<h4 id="把2D核分为1D核"><a href="#把2D核分为1D核" class="headerlink" title="把2D核分为1D核"></a>把2D核分为1D核</h4><p>如果你使用卷积方法对图像添加滤镜，你可以通过将2D核分裂为两个1D核来提高性能，这样可以使用两次卷积（一个维度可以使用一次）。</p>
<p>当然，你可以将2D核传给vImageConvolve函数。vImage使用2D核来完成9层8加的操作来计算每个像素结果。为了更好的性能，对每个1D卷积滤镜调用一次vImageConvolve函数。核分裂后，vImage通过每个卷积对每个像素执行3层2加的操作，加起来是6层4加。我们注意到将核分裂成两个后，算法复杂度在乘法上节省了1/3，在加法上节省了1/2。对于M×N的内核，处理消耗从M*N骤减到M+N。一个5×5的核分裂后的处理速度加快2.5倍，一个11×11的核分裂后可能加快超过5倍。</p>
<p>注意这个技术在常规情况下是比较慢的。一般在图像特别大，或图像无法存入内存时使用这个技术。</p>
<p>有几种情况下，分裂特别大的滤镜是执行卷积操作的唯一方案。一个总计超过2<sup>24</sup>的滤镜，vImage使用8位的卷积操作下，运行起来会有内存溢出的风险。这个时候，可以采用分裂滤镜来避免溢出，你甚至可以在放大滤镜之前，通过分裂技术向滤镜里添加更多的固定精度的点。这种技术的中间值精度损失程度未知。</p>
]]></content:encoded>
      
      <comments>gofee.me/2016/08/22/vImage-translation-01/#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
