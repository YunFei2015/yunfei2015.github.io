<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[关于storyboard不得不说的事]]></title>
    <url>%2F2017%2F07%2F26%2Fstoryboard-loading%2F</url>
    <content type="text"><![CDATA[自 iOS 5 时代苹果推出 Storyboard（以下简称SB）以来，关于使用代码手写 UI、SB 和 xib 之间的争论就一直存在。问题主要在于 Storyboard 的加载过程是否会影响性能，下面就分析一下 Storyboard 中的 ViewController 是怎么加载出来的。 细心的同学会发现，在编译的时候 Xcode 有个 Compiling Storyboard files 的过程。编译过程中，项目里用到的 SB 文件也会被编译，并以 .storyboarc 为扩展名最终保存在 APP 包内。.storyboardc 是一个文件夹，里面保存了描述编译后的 SB 信息的 Info.plist 文件，以及一系列 .nib 文件。原来的 SB 中的每个对象（也就是每个 ViewController）将会被编译成一个单独的 .nib，.nib 中包含了编码后的对应的对象层级。在加载一个 SB，并从中读取 ViewController 类型和 nib 的关系，来完成 UIStoryboard 的初始化。接下来读取某个 nib，并使用UINibDecoder 进行解码，将 nib 二进制还原为实际的对象，最后调用该对象的 initWithCoder： 完成各个属性的解码。最后，调用 awakeFromNib 方法，来通知开发者从 nib 的加载已经完毕。 可以看出，从只有一个 ViewController 的 SB 中加载这个 VC，与从有多个 ViewController 的 SB 中加载的情况，速度上并不会有什么区别。 原文： 再看关于 Storyboard 的一些争论]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>iOS</tag>
        <tag>Interface Build</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AFNetworking README 中文版]]></title>
    <url>%2F2017%2F01%2F25%2FAFNetworking-translate%2F</url>
    <content type="text"><![CDATA[AFNetworking README 中文版AFNetworking是iOS和Mac OS X平台上的轻量级网络库，在Foudation URL加载系统基础上构建，对构建于Cocoa的强大高级的网络抽象进行了扩充。它具有设计良好的、富有特性的、模块化结构的API接口集。 体系结构NSURLSession 会话 AFURLSessionManager AFHTTPSessionManager 序列化 AFHTTPRequestSerializer AFJSONRequestSerializer AFPropertyListRequestSerializer AFHTTPResponseSerializer AFJSONResponseSerializer AFXMLParserResponseSerializer AFXMLDocumentResponseSerializer(Mac OS X) AFPropertyListResponseSerializer AFImageResponseSerializer AFCompoundResponseSerializer 其他功能 AFSecurityPolicy AFNetworkReachabilityManager 用法AFURLSessionManagerAFURLSessionManager在一个定义好的NSURLSessionConfiguration对象基础上创建并管理一个NSURLSession对象, NSURLSessionConfiguration遵循, , , 协议. 创建一个下载任务1234567891011NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];NSURL *URL = [NSURL URLWithString:@"http://example.com/download.zip"];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSURLSessionDownloadTask *downloadTask = [manager downloadTaskWithRequest:request progress:nil destination:^NSURL *(NSURL *targetPath, NSURLResponse *response) &#123; NSURL *documentsDirectoryURL = [[NSFileManager defaultManager] URLForDirectory:NSDocumentDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:NO error:nil]; return [documentsDirectoryURL URLByAppendingPathComponent:[response suggestedFilename]];&#125; completionHandler:^(NSURLResponse *response, NSURL *filePath, NSError *error) &#123; NSLog(@"File downloaded to: %@", filePath);&#125;];[downloadTask resume]; 创建一个上传任务12345678910111213NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];NSURL *URL = [NSURL URLWithString:@"http://example.com/upload"];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSURL *filePath = [NSURL fileURLWithPath:@"file://path/to/image.png"];NSURLSessionUploadTask *uploadTask = [manager uploadTaskWithRequest:request fromFile:filePath progress:nil completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) &#123; if (error) &#123; NSLog(@"Error: %@", error); &#125; else &#123; NSLog(@"Success: %@ %@", response, responseObject); &#125;&#125;];[uploadTask resume]; 创建一个多表单请求的上传任务，带进度条1234567891011121314151617181920212223NSMutableURLRequest *request = [[AFHTTPRequestSerializer serializer] multipartFormRequestWithMethod:@"POST" URLString:@"http://example.com/upload" parameters:nil constructingBodyWithBlock:^(id&lt;AFMultipartFormData&gt; formData) &#123; [formData appendPartWithFileURL:[NSURL fileURLWithPath:@"file://path/to/image.jpg"] name:@"file" fileName:@"filename.jpg" mimeType:@"image/jpeg" error:nil]; &#125; error:nil];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:[NSURLSessionConfiguration defaultSessionConfiguration]];NSURLSessionUploadTask *uploadTask;uploadTask = [manager uploadTaskWithStreamedRequest:request progress:^(NSProgress * _Nonnull uploadProgress) &#123; // This is not called back on the main queue. // You are responsible for dispatching to the main queue for UI updates dispatch_async(dispatch_get_main_queue(), ^&#123; //Update the progress view [progressView setProgress:uploadProgress.fractionCompleted]; &#125;); &#125; completionHandler:^(NSURLResponse * _Nonnull response, id _Nullable responseObject, NSError * _Nullable error) &#123; if (error) &#123; NSLog(@"Error: %@", error); &#125; else &#123; NSLog(@"%@ %@", response, responseObject); &#125; &#125;];[uploadTask resume]; 创建一个数据任务123456789101112NSURLSessionConfiguration *configuration = [NSURLSessionConfiguration defaultSessionConfiguration];AFURLSessionManager *manager = [[AFURLSessionManager alloc] initWithSessionConfiguration:configuration];NSURL *URL = [NSURL URLWithString:@"http://httpbin.org/get"];NSURLRequest *request = [NSURLRequest requestWithURL:URL];NSURLSessionDataTask *dataTask = [manager dataTaskWithRequest:request completionHandler:^(NSURLResponse *response, id responseObject, NSError *error) &#123; if (error) &#123; NSLog(@"Error: %@", error); &#125; else &#123; NSLog(@"%@ %@", response, responseObject); &#125;&#125;];[dataTask resume]; 请求序列化请求序列化器通过将参数编码为字符串或HTTP请求体，结合URL字符串创建一个请求。 字符串格式的参数编码1[[AFHTTPRequestSerializer serializer] requestWithMethod:@"GET" URLString:URLString parameters:parameters error:nil]; GET http://example.com?foo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3 URL格式的参数编码1[[AFHTTPRequestSerializer serializer] requestWithMethod:@"POST" URLString:URLString parameters:parameters error:nil]; 123POST http://example.com/Content-Type: application/x-www-form-urlencodedfoo=bar&amp;baz[]=1&amp;baz[]=2&amp;baz[]=3 JSON格式的参数编码1[[AFJSONRequestSerializer serializer] requestWithMethod:@"POST" URLString:URLString parameters:parameters error:nil]; 123POST http://example.com/Content-Type: application/json&#123;&quot;foo&quot;: &quot;bar&quot;, &quot;baz&quot;: [1,2,3]&#125; 网络可达性管理AFNetworkReachabilityManager监控WWAN和WiFi的网络可达性。 不要使用Reachability决定是否发送原始请求； 应该尝试重发。 可以使用Reachability决定一个请求在什么时候自动重发； 虽然可能请求失败，但一个网络可达的Reachability通知是重新请求某些事物的好时候。 网络可达管理器是个很有用的工具，可以确定一个请求为什么失败。 一个网络请求失败后，通知用户“断线了”，比返回“请求超时”这种更技术更精确的错误要好。 参考 (https://developer.apple.com/videos/play/wwdc2012-706/). 共享的网络可达性管理器1234[[AFNetworkReachabilityManager sharedManager] setReachabilityStatusChangeBlock:^(AFNetworkReachabilityStatus status) &#123; NSLog(@"Reachability: %@", AFStringFromNetworkReachabilityStatus(status));&#125;];[[AFNetworkReachabilityManager sharedManager] startMonitoring]; 安全策略在你的APP里添加pinned X.509证书会帮你避免人为攻击和其他漏洞扫描。当应用处理敏感的用户数据或金融信息时，非常需要在具有SSL证书的HTTPS连接中执行所有操作。 ####允许无效SSL证书 12AFHTTPSessionManager *manager = [AFHTTPSessionManager manager];manager.securityPolicy.allowInvalidCertificates = YES; // not recommended for production]]></content>
      <categories>
        <category>第三方库</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
</search>